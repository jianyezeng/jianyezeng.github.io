<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理-高速缓冲存储器Cache</title>
      <link href="blog/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>blog/%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="xvcY8">高速缓冲存储器Cache</h1><blockquote><p>为了解决内存和CPU速度不匹配的问题</p></blockquote><p><h2 id="HpvIR">Cache工作原理</h2></p><blockquote><p>一般一个内存条的主存块大小（包含几个存储单元），与该内存条中DRAM芯片数目相等。(采用交叉编址)</p><p>主存一次给CPU一个存储单元，主存一次给Cache一个主存块。</p></blockquote><p><h3 id="S2m9J">Cache工程流程</h3><br>当CPU想要访问主存时，将地址信息给MAR，之后先检查Cache，查看是否有该地址信息对应存储单元的备份，若有，则直接从Cache取出存储单元，若没有，则访问主存，从主存处得到需要的信息，之后主存将该存储单元所在的主存块送入选定的Cache行中。</p><p>上述流程是唐书的说法，在CSAPP，软硬件接口中，对于Cache未命中时的处理，则是：</p><p>主存将主存块给Cache，之后CPU从Cache处取得所需的存储单元。(最好以国内教材为主)</p><p><h3 id="G2PHU">Cache结构</h3></p><blockquote><p>注意区分<strong><font style="color:#DF2A3F;">Cache行长与总容量</font></strong></p><font style="color:rgb(13, 13, 13);">cache行长通常指的是cache中一行的大小，这个大小通常只包括有效数据的容量，不包括元数据，比如标记位、标签等。</font><font style="color:rgb(13, 13, 13);">而在计算cache总容量时需要加上脏位、替换算法控制位、标记位等。</font></blockquote><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202502261929282.png" alt=""></p><ul><li>Cache又分为指令Cache和数据Cache，分别存储指令和数据。</li><li>Cache行的大小是与主存块大小相同的。</li><li>Cache由标记阵列和数据阵列组成，数据阵列用于保存主存传过来的数据，标记阵列用于保存Cache行中的标记字段，由有效位（说明该记录是否为空，<strong>在发生进程切换时，需要清空Cache，这个时候会将有效位全部置为0</strong>）和标记阵列组成，标记阵列的组成并不固定，最多包含以下三个部分：TAG字段、保存脏位、保存算法替换位。</li></ul><p><h2 id="JN513">Cache和主存映射方式</h2></p><p><h3 id="ER6ag">直接映射</h3></p><blockquote><p>将地址信息分为三个部分，低位的块内偏移信息，中间的块号，高位的TAG字段。（具体的实现，直接取余即可，由于采用了二进制，后n位就是块内偏移信息，以此类推）</p><p>该方法不需要替换算法，因为每个主存块对应的Cache行只有一个，当一个主存块数据被存入一个Cache行中时，若发送了替换，一定是该原Cache行原来的数据被替换掉。</p></blockquote><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202502261930440.png" alt=""></p><p><h4 id="nJD7c">向Cache存入主存块</h4><br>首先根据主存块地址信息中间的块号，找到该主存块在Cache中对应的Cache行，直接将主存块的数据放入数据阵列（数据区），将地址信息中高位的信息放入TAG字段，作为标记信息。</p><p><h4 id="YRXEW">向Cache取出主存块</h4><br>已有某个存储单元的地址信息，该地址信息由三部分组成：低位的块内偏移信息A，中间的块号B，高位的C，首先根据块号B，找到Cache对应行，先检查其有效位是否为1，若不为1，则未命中，否则将C和Cache行的TAG字段进行比较，若一致，则说明命中，之后根据块内偏移信息，通过多路选择器，选出所需的存储单元。</p><p>需要注意，使用直接映射，只需要一个比较器。</p><p><h3 id="bnKvP">全相联映射</h3></p><blockquote><p>将地址信息分为两部分，低位的块内偏移信息和高位的TAG字段</p></blockquote><p><h4 id="mDlqe">向Cache存入主存块</h4><br>找到Cache中一个空闲行（根据有效位），将该主存块的数据放入该行的数据阵列，将地址信息除了块内偏移的部分放入TAG。（一般是从小到大有序查找空闲行，当然要根据题意）</p><p><h4 id="o27u5">向Cache取出主存块</h4><br><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202502261930724.png" alt=""></p><p>将目的存储单元的地址信息的高位与整个Cache所有行的TAG字段依次对比，找到正确的Cache行，之后根据块内偏移信息，通过多路选择器，选出所需的存储单元。</p><p>需要注意采用这个方法，若一个一个对比效率非常慢，可以给每个Cache行都设置一个比较器，这样就需要n（Cache行数）个比较器，但功耗大。但是呢，该方法在一些教材出现了，一些教材并未出现，因此仅了解即可。（另外，即使每行都设置一个比较器，由于电路实现较为复杂，依然会慢一些。）</p><p><h3 id="z9N9r">组相联映射</h3></p><blockquote><p>将地址分为三个部分：TAG字段、组号、块内偏移地址。将多个Cache合并成一个组。</p><ol><li>组相联映射虽然把几个Cache行拼接成了一个Cache组，但是主存地址的TAG字段并未减少，反而增加了（相较于直接映射）</li><li>组相联中比较器的个数与路数有关，比如4路组相联比较器就有四个</li><li>组相联若出现组内需要替换时，同样替换算法仍然采用随机替换或先进先出替换或LRU替换  </li></ol></blockquote><p>组相联中，会把各组各行的标记项排成一排，将各组从上到下排列，形成一个二维的标记阵列。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202502261931896.png" alt=""></p><p><h4 id="KbiUr">向Cache存入主存块</h4><br>首先根据地址信息中的组号，找到对应的Cache组，从中找到空闲的Cache行，将数据信息放入数据阵列，将标记信息放入TAG字段。</p><p><h4 id="GOhrO">向Cache取出主存块</h4><br>首先根据地址信息的组号，找到对应的Cache组。将目的存储单元的地址信息的TAG与Cache组所有Cache行的TAG字段依次对比，找到正确的Cache行，之后根据块内偏移信息，通过多路选择器，选出所需的存储单元。</p><p>比较器数量等于一个Cache组中Cache行数目。</p><p><h2 id="H99DO">Cache中主存块替换算法</h2></p><p><h3 id="AlaHW">随机算法</h3><br>随机替换Cache行，未根据程序的局部性原理。</p><p><h3 id="oHspr">先进先出算法</h3><br>选择最早调入的Cache行替换，未根据程序的局部性原理。</p><p><h3 id="r4enc">LRU算法</h3></p><blockquote><p>采用此方法，需要在Cache行中加入一个算法替换位。</p><p>当集中访问的存储区超过Cache组大小时，命中率可能很低。例如Cache行数为4，遇到1 2 3 4 5 1 2 3 4 5……</p><p>频繁的换入换出（刚被替换的块很快又被换入）的现象称为<strong>抖动</strong>。</p></blockquote><p><h4 id="rD9eM">另一种角度</h4><br>该算法可以看作维持一个数组A，其大小为计数器可能的取值，4个Cache行，也就是4。（每个Cache行计数器值一定不一样，不会出现一个位置多个Cache的情况）</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标/计数器值<br/>（多少次没有访问）</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">Cache行</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">d</td></tr></tbody></table></div><p>当有空闲行，要插入新的Cache行，因此是刚刚访问的，计数器值最小，也就是放在A[0]的位置。那么数组原有的数据就要集体右移，以保持有序。</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标/计数器值<br/>（多少次没有访问）</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">Cache行</td><td style="text-align:center">d</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td></tr></tbody></table></div><p>当要替换掉某个行时，选择最大的，即A[3]。</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标/计数器值<br/>（多少次没有访问）</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">Cache行</td><td style="text-align:center">d</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p>之后插入新行</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标/计数器值<br/>（多少次没有访问）</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">Cache行</td><td style="text-align:center">e</td><td style="text-align:center">d</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p>若中间的的d被访问了，他的计数器值就变成最小的了，那么数组其他元素要给他腾位置，但是a和b显然是不用动的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标/计数器值<br/>（多少次没有访问）</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">Cache行</td><td style="text-align:center">d</td><td style="text-align:center">e</td><td style="text-align:center">a</td><td style="text-align:center">b</td></tr></tbody></table></div><p><h4 id="xMpuj">算法过程：</h4></p><ul><li>命中，被选中的行，计数器为0，比该行原计数器值低的Cache计数器+1，其余行不变；</li><li>未命中，若Cache中仍有空闲行，加入新的Cache行后，该Cache行计数器为0，其余行计数器+1；</li><li>未命中，且Cache中没有空闲行，选择计数器最大的行替换成新的Cache行，新的Cache行计数器为0，其余行+1。</li></ul><p><h4 id="mDZyG">算法特点：</h4></p><ul><li>算法替代位位数：若有$ 2^n $个Cache行，则需要n位；需要注意组相连映射，这里的Cache行数即一个组内的Cache行数。</li><li>Cache装满后，所有的Cache行计数器的值一定不重复。</li></ul><p><h3 id="v6J6F">最不经常使用算法</h3><br>每个Cache一个计数器，当某个Cache被访问了，其计数器+1。插入新的Cache时，计数器置0；当Cache满需要替换时，选择计数器最小的替换出去。若存在多个计数器值最小的Cache行，可以按照行号递增或先进先出策略进行选择。其计数器的值可能会变得很大，需要较多位数。</p><p><h2 id="yqL5P">Cache的一致性问题</h2></p><p><h3 id="V5PBL">写命中时</h3></p><p><h4 id="zeRI7">全写法（直写法）</h4><br>CPU对Cache写命中时，把数据同时写到主存和Cache。</p><p><h4 id="W8lQS">写回法</h4></p><blockquote><p>需要在Cache行的标记字段中设置一个脏位（修改位），用于标记该Cache是否被写过。</p></blockquote><p>CPU对Cache写命中时，仅把数据写到Cache，而不写到主存，但是需要将脏位置1。当Cache行被替换下去时，若脏位为1，说明被修改过，需要将其写回主存。</p><p><h3 id="etIjQ">写不命中时</h3></p><p><h4 id="MJs6Y">写分配法</h4></p><blockquote><p>搭配全写法/写回法是两个操作，需要注意</p><p>可以从这个方面记忆，全写法一般用于各级Cache之间，在低级的Cache改也很快，所以可以不调入高级的Cache就改，写回法用于Cache和主存之间，不先调入Cache就太慢了。</p></blockquote><ul><li>若与全写法搭配，则先在主存修改，之后将主存块调入Cache行；</li><li>若与写回法搭配，先调入Cache行，再修改。</li></ul><p><h4 id="eZdoR">非写分配法</h4><br>只更新主存，而不把主存块调入Cache。</p><p><h3 id="dk2Uj">各个方法之间的搭配、适用情景及原因</h3></p><blockquote><p>括号内的以及1和2的第二点仅供参考，便于记忆</p></blockquote><ol><li>全写法常与非写分配法搭配，用于各级Cache之间，原因：</li></ol><ul><li>全写法与非写分配法是重视主存的体现(当然，若是各级Cache之间，就是重视低级的Cache，各级Cache都很重要，都要重视）；</li><li>全写法同时写主存和Cache，写主存很慢的，因此可以适用于各级Cache之间，毕竟Cache很快，再慢能慢到哪里去。使用非写分配法，是因为即使不调入高级的Cache，在低级的Cache，想访问也很快。</li></ul><ol><li>写回法常与写分配法搭配，用于Cache和主存之间，原因：</li></ol><ul><li>写回法与非写分配法是重视Cache的体现（主存？比不上Cache一根，所以可以适用于Cache和主存之间）；</li><li>访问主存太慢了，因此要尽可能不访问主存，所以使用写回法。根据局部性原来，已经被访问过的主存块很可能再次被访问，若干不调入Cache，再次被访问还要从主存取，太慢了，因此使用写分配法（当然先调入Cache再改，不然在主存改太慢了）。</li></ul><ol><li>事实上， 写回法一般搭配写分配法使用，而全写法则搭配写分配法、非写分配法都很常见。（毕竟都用写回法了，命中时只写Cache，不命中时怎么会不调入Cache呢？）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动器或UNC共享不存在或不能访问</title>
      <link href="blog/%E9%A9%B1%E5%8A%A8%E5%99%A8%E6%88%96UNC%E5%85%B1%E4%BA%AB%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE/"/>
      <url>blog/%E9%A9%B1%E5%8A%A8%E5%99%A8%E6%88%96UNC%E5%85%B1%E4%BA%AB%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%88%96%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="驱动器或UNC共享不存在或不能访问"><a href="#驱动器或UNC共享不存在或不能访问" class="headerlink" title="驱动器或UNC共享不存在或不能访问"></a>驱动器或UNC共享不存在或不能访问</h1><p>当你满心欢喜得点击exe安装程序准备安装某个软件时，突如其来的弹窗让你不知所措。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202311212207207.png" alt="截图"></p><p>？？什么情况？</p><p>什么叫做驱动器或UNC共享不存在或不能访问？</p><p>那么为什么会出现这个弹窗安装失败呢？</p><p>这个弹窗说明该软件之前安装过，而且当时安装的时候没有安装到本地磁盘（可逆安装在U盘或者移动硬盘上了），这次的安装不会出现安装向导，安装向导不会提示你选择安装位置。</p><p>那么该如何解决呢？</p><p>方案一：把原来安装的U盘或者移动硬盘插回来，再卸载之后就可以顺利安装再本地磁盘上了。（不过都能找到U盘或者移动硬盘了，为什么不直接用呢？）</p><p>方案二：</p><ol><li><p>打开注册表（<code>win+r</code>输入<code>regedit</code>）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202311212216205.png" alt="打开注册表"></p></li><li><p>查找对应的目标</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202311212217802.png" alt="查找对应的目标"></p></li><li><p>删除！之后就可以顺利安装了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式求值</title>
      <link href="blog/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>blog/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><blockquote><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><p>有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。<br>每个操作数（运算对象）都可以是一个整数或者另一个表达式。<br>两个整数之间的除法总是 向零截断 。<br>表达式中不含除零运算。<br>输入是一个根据逆波兰表示法表示的算术表达式。<br>答案及所有中间计算结果可以用 32 位 整数表示。</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) <em> ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) </em> ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;numStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>; <span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;tokens.size(); s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[s] == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                i = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                j = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                numStack.push(i+j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[s] == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                i = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                j = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                numStack.push(j-i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[s] == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                i = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                j = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                numStack.push(i*j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[s] == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                i = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                j = numStack.top();</span><br><span class="line">                numStack.pop();</span><br><span class="line">                numStack.push(j/i);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> numStack.push(stoll(tokens[s]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这道题只需要按照逆波兰表达式使用栈计算的规则：<strong>遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈</strong>中即可。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记：Res2Net</title>
      <link href="blog/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%EF%BC%9ARes2Net/"/>
      <url>blog/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%EF%BC%9ARes2Net/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文笔记：Res2Net"><a href="#论文笔记：Res2Net" class="headerlink" title="论文笔记：Res2Net"></a>论文笔记：Res2Net</h1><blockquote><p> Res2Net: A New Multi-Scale Backbone Architecture</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​    在多个尺度上表示特征对于许多视觉任务非常重要。主干卷积神经网络 (CNN) 的最新进展不断表现出更强的多尺度表示能力，从而在广泛的应用中取得了一致的性能提升。然而，大多数现有方法以分层方式表示多尺度特征。在本文中，我们提出了一种新颖的 CNN 构建块，即 Res2Net，通过在单个残差块内构建分层残差状连接。Res2Net 表示颗粒级别的多尺度特征，并增加每个网络层的感受野范围。所提出的 Res2Net 块可以插入到最先进的主干 CNN 模型中，例如 ResNet、ResNeXt 和 DLA。我们在所有这些模型上评估 Res2Net 块，并在广泛使用的数据集（例如 CIFAR-100 和 ImageNet）上展示了比基线模型一致的性能提升。进一步的消融研究和代表性计算机视觉任务的实验结果，即目标检测、类激活映射和显著目标检测，进一步验证了Res2Net相对于最先进的基线方法的优越性。源代码和经过训练的模型可在 <a href="https://mmcheng.net/res2net/">https://mmcheng.net/res2net/</a> 上获得。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    可视模式在自然场景中以多尺度出现。首先，物体可能在单幅图像中以不同的尺寸出现。其次，目标的必要语境信息可能会比对象本身更重要。例如，我们需要以大桌子为背景，以更好地判断放在桌子上的黑色小斑点是杯子还是笔筒。最后，理解不同尺度的信息对于理解目标（例如细粒度分类和语义分割）至关重要。因此，对于计算机视觉任务设计多尺度功能至关重要。</p><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>​    提出了一种简单而有效的多尺度处理方法。用一组较小的滤波器组替换n个通道的3×3滤波器，每个滤波器组有w个通道。即将输入特征分成了几组。一组滤波器首先从一组输入特征图中提取要素。然后将上一组的输出特征图与另一组输入特征图一起发送到下一组滤波器。此过程重复几次，直到处理完所有输入特征图。最后，将所有组的特征图连接(concat)并送到另个1×1滤波器，以完全融合信息。</p><h3 id="Res2Net模块"><a href="#Res2Net模块" class="headerlink" title="Res2Net模块"></a>Res2Net模块</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202310151636087.jpeg" alt=""></p><p>​    如上图所示，Res2Net与ResNet的主要差别就是两个1x1卷积之间部分的替换。在Res2Net中，经过1x1卷积后，将其分成四份（$x_1,x_2,x_3,x_4$），$x_1$不作处理，直接给$y_1$，而$x_2$在经过3x3卷积后，传递给$y_2$，同时传递给$x_3$，这样$x_3$也就获得了$x_2$的信息。后面以此类推。</p><p>​    滤波器组通道数与原通道数和分成的份数的关系为：</p><script type="math/tex; mode=display">n=s*w</script><p>​    假设共分成s份，即$x_i$，其中$ (i=1,2,…,s)$,用$K_i$代表3x3卷积，则输出$y_i$为：</p><script type="math/tex; mode=display">y_i=\left\{\begin{matrix} x_i  &i=1;\\ K_i(x_i) &i=2;\\ K_i(x_i+y_{i-1}) &i =3,4,…,s \end{matrix}\right.</script><p>​    除了现有的深度，宽度和通道数之外，Res2Net策略还公开了一个新的维度，即尺度（Res2Net块中特征组的数量）。所提出的方法在更细粒度的水平上利用了多尺度，这与利用分层操作的现有方法正交。因此，可以很容易地将Res2Net模块插入许多现有的CNN架构中。大量的实验结果表明，Res2Net模块可以进一步提高最新的CNN的性能，例如ResNet，ResNeXt和DLA。Res2Net的巧妙之处是利用s作为尺度的控制参数。这样做的优点是s越大感受野越大，且级联(conact)引入的计算/内存开销小，可以忽略不计。</p><h3 id="集成现有模型结构的Res2Net-模块"><a href="#集成现有模型结构的Res2Net-模块" class="headerlink" title="集成现有模型结构的Res2Net 模块"></a>集成现有模型结构的Res2Net 模块</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202310151700485.JPG" alt="集成现有模型结构的Res2Net 模块"></p><p>​        可以将Res2Net模块与ResNeXt、SE结合：参照ResNeXt，将每组中的3×3卷积改为分组卷积；在残差连接前加入SE block。形成的网络结构如上图所示。</p><h2 id="取得效果"><a href="#取得效果" class="headerlink" title="取得效果"></a>取得效果</h2><p>​    表 1 显示了 ImageNet 数据集上的 top-1 和 top-5 测试误差。可以看出Res2Net更好。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202310151702573.JPG" alt="table1"></p><p>​    更深层次的网络已被证明对视觉任务具有更强的表示能力。为了更深入地验证模型，将 Res2Net 和 ResNet 的分类性能进行了比较。如表 2 所示，Res2Net在 top-1 错误方面实现了 对ResNet的显着性能提升。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202310151707981.JPG" alt="table2"></p><p>​    表3显示了ImageNet数据集上具有不同scale的Res2Net-50的Top-1和Top-5测试误差。w为各scale的通道数，s为scale。由表3可看出，网络的性能随着s的增加而增加。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202310151707844.JPG" alt="table3"></p><p>​    其他实验数据详见论文，不一一赘述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    Res2Net模块能进一步提取多尺度特征。用Res2Net代替原网络中ResNet Backbone，能够提高baseline网络在图像分类、目标检测等多种计算机视觉任务中的性能，而且几乎不增加计算量。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://arxiv.org/abs/1904.01169">Res2Net: A New Multi-scale Backbone Architecture (arxiv.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络协议知识点梳理</title>
      <link href="blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
      <url>blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><div class="table-container"><table><thead><tr><th>协议</th><th>协议特点</th></tr></thead><tbody><tr><td>停止等待协议</td><td>W_R= W_T=1 ，实现简单，信道利用率</td></tr><tr><td>后退 N 帧协议 (GBN)</td><td>W_R=1,W_T&gt;1，使用累计确认机制</td></tr><tr><td>选择重传协议 (SR)</td><td>W_R&gt;1,W_T&gt;1,使用 NAK 帧指定需要重传的 帧</td></tr><tr><td>纯 ALOHA 协议</td><td>想发就发，超时则等待随机时间后重发</td></tr><tr><td>时隙 ALOHA 协 议</td><td>只能在时隙开始 时发送，重传策 略和纯 ALOHA 类似</td></tr><tr><td>CSMA 协议</td><td>先听后发、越时则等待随机时间后重新侦听</td></tr><tr><td>CSMA/CD 协议</td><td>发前先听、边发边听、冲突停发、随机重发</td></tr><tr><td>CSMA/CA 协议</td><td>在 CSMA 的基础上加人冲突避免机制， 在发送 数据前等待一个 IFS 再决定是否发送</td></tr><tr><td>令牌传递协议</td><td>主机按顺序传递令牌， 持有令牌的主机才能发 送数据</td></tr><tr><td>以太网 802.3 标 准</td><td>定义了以太网的物理层结构， 数据链路层协议 以及标准以太网帧的结构</td></tr><tr><td>无线局域网 802.11 系列标准</td><td>定义了无线局城网的结构以及无线数据帧的 结构</td></tr><tr><td>虚拟局域网 802.1Q 标准</td><td>定义了 VLAN 字段的结构以及 VLAN 字段在 以太网顿中的位置</td></tr><tr><td>PPP 协议</td><td>广域网中两节点之间点对点通信使用的协议</td></tr></tbody></table></div><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><div class="table-container"><table><thead><tr><th>协议</th><th>主要作用</th><th>主要特点</th></tr></thead><tbody><tr><td>OSPF</td><td>应用于自治系统 内部的路由协议</td><td>基于链路状态路由算法；<br>每个路由器拥有全网的拓 扑结构；<br>采用Dijkstra算法计算最短路径;<br>更适用于中大型网络;<br>通过IP协议传输</td></tr><tr><td>IPv4</td><td>屏蔽异构网络的细节，使互联的各级计算机网络形成一个通用的整体</td><td>IP 协议的第四版， 采用 32 位的 IP 地址</td></tr><tr><td>IPv6</td><td>屏蔽异构网络的细节，使互联的各级计算机网络形成一个通用的整体</td><td>IP 协议的第六版， 采用 128 位的 IP 地址，从根本上解决了 IPv4 地址空间不 足的问题</td></tr><tr><td>ARP</td><td>获取与 IP 地址对应的硬件地址</td><td>ARP 请求分组采用广播&lt;&gt;ARP 响应分组采用单播</td></tr><tr><td>ICMP</td><td>作为 IP 协议的补充,报告传输中的差错和异常</td><td>基于 IP 协议传输 ICMP 报 文</td></tr><tr><td>IGMP</td><td>负责管理 IPv4 组播成员的管理</td><td>IGMP 基于 IP 协议,IGMP报文封装在IP报文中</td></tr></tbody></table></div><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><div class="table-container"><table><thead><tr><th>协议</th><th>IP 分组首部协议字段</th><th>功能</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td>TCP</td><td>6</td><td>复用分用 流量控制 拥塞控制 可靠传输</td><td>面向连接；保证可靠传输； 面向字节；进行拥塞控制； 支持点对点通信，不支持多 播和广播；提供全双工通信</td><td>对可靠性要求高的应用；要求可靠 传输的协议，如 HTTP、HTTPS、FTP 等协议，POP、SMTP 等邮件传输的 协议</td></tr><tr><td>UDP</td><td>17</td><td>复用分用 差错检测</td><td>无连接；不保证可靠传输； 面向报文；  不进行拥塞控 制； 支持一对一、 一对多、 多对一、多对多的通信方 式； 首部仅有八字节</td><td>对时间要求高的实时应用(如直播、 电话视频)、只进行简单的请求 -响 应通信的进程、某些路由选择更新 协议(如 RIP)、需要进行多播的应用</td></tr></tbody></table></div><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><div class="table-container"><table><thead><tr><th>简称</th><th>全称</th><th>协议用途</th><th>默认端☐</th><th>下层协议</th></tr></thead><tbody><tr><td>DNS</td><td>域名解析协议 Domain Name System</td><td>将域名映射成 IP 地址(正向解析) 将 IP 地址映射成域名(反向解析)</td><td>53</td><td>UDP</td></tr><tr><td>FTP</td><td>文件传输协议 File Transfer Protocol</td><td>在客户端和服务器之间传输文件</td><td>21(命令) 20(数据)</td><td>TCP</td></tr><tr><td>TFTP</td><td>简单文件传输协议 Trivial File Transfer Protocol</td><td>在客户端和服务器之间进行简单文 件传输</td><td>69</td><td>UDP</td></tr><tr><td>SMTP</td><td>简单邮件传输协议 Simple Mail Transfer Protocol</td><td>将邮件从本地邮件客户端(用户代理) 推向邮件服务器以及在邮件服务器 之间传输邮件</td><td>25</td><td>TCP</td></tr><tr><td>POP3</td><td>邮局协议版本 3 Post Office Protocol - Version3</td><td>从远程邮件服务器”拉取”邮件到本 地电子邮件客户端(用户代理)</td><td>110</td><td>TCP</td></tr><tr><td>IMAP</td><td>因特网报文存取协议 Internet Mail Access Protocol</td><td>比 POP3 更强大的邮件访问协议，可 以对远程邮件服务器进行操作以及 获取报文部分内容</td><td>143</td><td>TCP</td></tr><tr><td>MIME</td><td>多用途网际邮件扩充 Multipurpose Internet Mail Extensions</td><td>支持电子邮件系统传输图片、音频、 视频等非 ASCII 码数据</td><td>-</td><td>-</td></tr><tr><td>HTTP</td><td>超文本传输协议 Hyper Text Transfer Protocol</td><td>请求网络资源， 规定了如何构造客户 端的请求并将其发送到服务器以及 服务器如何响应这些请求</td><td>80(HTTP) 443(HTTPS)</td><td>TCP</td></tr><tr><td>TELNET</td><td>远程登录协议</td><td>在本地主机上实现远程登录</td><td>23</td><td>TCP</td></tr><tr><td>二 、传输层</td><td></td><td></td><td></td><td></td></tr><tr><td>协议</td><td>IP 分组首部 协议字段</td><td>功能</td><td>特点</td><td>应用场景</td></tr><tr><td>TCP</td><td>6</td><td>复用分用 流量控制 拥塞控制 可靠传输</td><td>面向连接；保证可靠传输； 面向字节；进行拥塞控制； 支持点对点通信，不支持多 播和广播；提供全双工通信</td><td>对可靠性要求高的应用；要求可靠 传输的协议，如 HTTP、HTTPS、FTP 等协议，POP、SMTP 等邮件传输的 协议</td></tr><tr><td>UDP</td><td>17</td><td>复用分用 差错检测</td><td>无连接；不保证可靠传输； 面向报文；  不进行拥塞控 制； 支持一对一、 一对多、 多对一、多对多的通信方 式； 首部仅有八字节</td><td>对时间要求高的实时应用(如直播、 电话视频)、只进行简单的请求 -响 应通信的进程、某些路由选择更新 协议(如 RIP)、需要进行多播的应用</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>街景字符识别-YOLOv8目标检测模型</title>
      <link href="blog/%E8%A1%97%E6%99%AF%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB-YOLOv8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>blog/%E8%A1%97%E6%99%AF%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB-YOLOv8%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="街景字符识别-YOLOv8目标检测模型"><a href="#街景字符识别-YOLOv8目标检测模型" class="headerlink" title="街景字符识别-YOLOv8目标检测模型"></a>街景字符识别-YOLOv8目标检测模型</h1><h2 id="背景详情"><a href="#背景详情" class="headerlink" title="背景详情"></a>背景详情</h2><p><strong>赛题链接</strong>：<a href="https://tianchi.aliyun.com/competition/entrance/531795/information">街景字符编码识别<em>学习赛</em>赛题与数据_天池大赛-阿里云天池 (aliyun.com)</a></p><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题来源自Google街景图像中的门牌号数据集（The Street View House Numbers Dataset, SVHN），并根据一定方式采样得到比赛数据集。</p><p>数据集报名后可见并可下载，该数据来自真实场景的门牌号。训练集数据包括3W张照片，验证集数据包括1W张照片，每张照片包括颜色图像和对应的编码类别和具体位置；为了保证比赛的公平性，测试集A包括4W张照片，测试集B包括4W张照片。</p><h4 id="数据集样本展示"><a href="#数据集样本展示" class="headerlink" title="数据集样本展示"></a>数据集样本展示</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307211620050.jpeg" alt="enter image description here"></p><p>需要注意的是本赛题需要选手识别图片中所有的字符，为了降低比赛难度，我们提供了训练集、验证集和测试集中字符的位置框。</p><h4 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h4><p>所有的数据（训练集、验证集和测试集）的标注使用JSON格式，并使用文件名进行索引。如果一个文件中包括多个字符，则使用列表将字段进行组合。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Field</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td style="text-align:center">左上角坐标Y</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">字符高度</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">左上角坐标X</td></tr><tr><td style="text-align:center">width</td><td style="text-align:center">字符宽度</td></tr><tr><td style="text-align:center">label</td><td style="text-align:center">字符编码</td></tr></tbody></table></div><p>注：数据集来源自SVHN，网页链接<a href="http://ufldl.stanford.edu/housenumbers/，并进行匿名处理和噪音处理。">http://ufldl.stanford.edu/housenumbers/，并进行匿名处理和噪音处理。</a></p><h3 id="评测标准"><a href="#评测标准" class="headerlink" title="评测标准"></a>评测标准</h3><p>评价标准为准确率，选手提交结果与实际图片的编码进行对比，以编码整体识别准确率为评价指标，结果越大越好，具体计算公式如下：</p><script type="math/tex; mode=display">score =编码识别正确的数量测试集图片数量/测试集图片数量编码识别正确的数量​</script><h3 id="结果提交"><a href="#结果提交" class="headerlink" title="结果提交"></a>结果提交</h3><p>预测结果的格式与sample_submit.csv中的格式一致，提交文件后缀名为csv。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_name, file_code</span><br><span class="line">0010000.jpg,451</span><br><span class="line">0010001.jpg,232</span><br><span class="line">0010002.jpg,45</span><br><span class="line">0010003.jpg,67</span><br><span class="line">0010004.jpg,191</span><br><span class="line">0010005.jpg,892</span><br></pre></td></tr></table></figure><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>对于这个赛题，YOLO可以取得更加优秀的预测结果。</p><h3 id="制作数据集"><a href="#制作数据集" class="headerlink" title="制作数据集"></a>制作数据集</h3><h4 id="数据集格式"><a href="#数据集格式" class="headerlink" title="数据集格式"></a>数据集格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">├── data&#x2F;train</span><br><span class="line">│   ├── data&#x2F;train&#x2F;images</span><br><span class="line">│   │   ├── data&#x2F;train&#x2F;images&#x2F;00000.png</span><br><span class="line">│   │   ├── data&#x2F;train&#x2F;images&#x2F;00001.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── data&#x2F;train&#x2F;labels</span><br><span class="line">│   │   ├── data&#x2F;train&#x2F;labels&#x2F;00000.txt</span><br><span class="line">│   │   ├── data&#x2F;train&#x2F;labels&#x2F;00001.txt</span><br><span class="line">│   │   ├── ...</span><br><span class="line">├── data&#x2F;val</span><br><span class="line">│   ├── data&#x2F;val&#x2F;images</span><br><span class="line">│   │   ├── data&#x2F;val&#x2F;images&#x2F;00000.png</span><br><span class="line">│   │   ├── data&#x2F;val&#x2F;images&#x2F;00001.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── data&#x2F;val&#x2F;labels</span><br><span class="line">│   │   ├── data&#x2F;val&#x2F;labels&#x2F;00000.txt</span><br><span class="line">│   │   ├── data&#x2F;val&#x2F;labels&#x2F;00001.txt</span><br><span class="line">│   │   ├── ...</span><br><span class="line">├── data&#x2F;test</span><br><span class="line">│   ├── data&#x2F;test&#x2F;images</span><br><span class="line">│   │   ├── data&#x2F;test&#x2F;images&#x2F;00000.png</span><br><span class="line">│   │   ├── data&#x2F;test&#x2F;images&#x2F;00001.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">└──mydata.yaml</span><br></pre></td></tr></table></figure><p>其中<code>images</code>文件夹用来存储训练或测试时需要用到图片，而<code>labels</code>中存储这些图片对应的labels（可根据<code>json</code>文件得到）。</p><h4 id="得到所需txt文档"><a href="#得到所需txt文档" class="headerlink" title="得到所需txt文档"></a>得到所需txt文档</h4><p>比赛给出的<code>labels</code>为<code>json格式</code>，我们需要将其转换为可用于YOLO目标检测的格式。</p><p>首先需要对数据进行处理，对其进行归一化处理，并得到一个包含每张图片对应txt文档的文件夹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">dict1,shape</span>):</span></span><br><span class="line">    l=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dict1[<span class="string">&#x27;left&#x27;</span>])):</span><br><span class="line">        l += <span class="built_in">str</span>(dict1[<span class="string">&#x27;label&#x27;</span>][i])+<span class="string">&#x27; &#x27;</span>+\</span><br><span class="line">        <span class="built_in">str</span>((dict1[<span class="string">&#x27;left&#x27;</span>][i]+dict1[<span class="string">&#x27;width&#x27;</span>][i]/<span class="number">2</span>)/shape[<span class="number">1</span>])+<span class="string">&#x27; &#x27;</span>+\</span><br><span class="line">        <span class="built_in">str</span>((dict1[<span class="string">&#x27;top&#x27;</span>][i]+dict1[<span class="string">&#x27;height&#x27;</span>][i]/<span class="number">2</span>)/shape[<span class="number">0</span>])+<span class="string">&#x27; &#x27;</span>+\</span><br><span class="line">        <span class="built_in">str</span>(dict1[<span class="string">&#x27;width&#x27;</span>][i]/shape[<span class="number">1</span>])+<span class="string">&#x27; &#x27;</span>+\</span><br><span class="line">        <span class="built_in">str</span>(dict1[<span class="string">&#x27;height&#x27;</span>][i]/shape[<span class="number">0</span>])\</span><br><span class="line">              +<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">    </span><br><span class="line">f = <span class="built_in">open</span>(</span><br><span class="line">    <span class="string">&quot;val.json&quot;</span>,</span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">data = json.load(f)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    img = cv2.imread(<span class="string">r&#x27;val/images&#x27;</span>+<span class="string">&#x27;/&#x27;</span>+i)</span><br><span class="line">    shape = img.shape</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">r&#x27;val/labels/&#x27;</span>+i[<span class="number">0</span>:<span class="number">6</span>]+<span class="string">&#x27;.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(process(data[i],shape))</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><h4 id="编写YAML"><a href="#编写YAML" class="headerlink" title="编写YAML"></a>编写YAML</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">path:</span> <span class="string">D:\project\Street-View-Character-Recognition\YOLO\data</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">D:\project\Street-View-Character-Recognition\YOLO\data\train\images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">D:\project\Street-View-Character-Recognition\YOLO\data\val\images</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nc:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">0</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">2</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">3</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">4</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">5</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">6</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">7</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">8</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>将<code>path</code>、<code>train</code>、<code>val</code>的地址更改的对应文件夹地址（最好使用绝对地址）。</p><h3 id="YOLOv8下载"><a href="#YOLOv8下载" class="headerlink" title="YOLOv8下载"></a>YOLOv8下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ultralytics</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/ultralytics</span><br><span class="line">cd ultralytics</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h3 id="开始train！"><a href="#开始train！" class="headerlink" title="开始train！"></a>开始train！</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = YOLO(yolo_vn)</span><br><span class="line">model.train(data=train_data,batch=<span class="number">8</span>,epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>训练结果将保存在<code>./ultralytics/runs/detect/train</code>目录下。</p><h3 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = YOLO(model_best)</span><br><span class="line">model.predict(source=test_data,save_txt=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>预测结果将保存在<code>./ultralytics/runs/detect/predict/labels</code>目录下。</p><h3 id="对预测结果进行处理"><a href="#对预测结果进行处理" class="headerlink" title="对预测结果进行处理"></a>对预测结果进行处理</h3><p>预测的结果仍然是一个包含多个txt文档的文件夹，我们需要对其进行处理，得到可提交的<code>csv</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_targets_from_txt</span>(<span class="params">image_directory,txt_directory, csv_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(csv_file, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">        writer = csv.writer(csv_file)</span><br><span class="line">        writer.writerow([<span class="string">&#x27;file_name&#x27;</span>, <span class="string">&#x27;file_code&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(image_directory):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.png&#x27;</span>):</span><br><span class="line">                img_name = os.path.splitext(filename)[<span class="number">0</span>]  <span class="comment"># 获取图片名</span></span><br><span class="line">                txt_path = os.path.join(txt_directory, <span class="string">f&#x27;<span class="subst">&#123;img_name&#125;</span>.txt&#x27;</span>) </span><br><span class="line">                <span class="comment"># 如果文本文件存在，读取标签内容</span></span><br><span class="line">                <span class="keyword">if</span> os.path.exists(txt_path):</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(txt_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> txtfile:</span><br><span class="line">                        targets = []</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 读取每一行的目标类别</span></span><br><span class="line">                        <span class="keyword">for</span> line <span class="keyword">in</span> txtfile:</span><br><span class="line">                            line = line.strip()</span><br><span class="line">                            <span class="keyword">if</span> line:</span><br><span class="line">                                target_class = line[<span class="number">0</span>]</span><br><span class="line">                                targets.append(target_class)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 将目标类别列表连接成一个数字</span></span><br><span class="line">                        file_code = <span class="string">&#x27;&#x27;</span>.join(targets)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 获取当前txt文件的文件名</span></span><br><span class="line">                        file_name = os.path.splitext(img_name)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 写入csv文件中的一行</span></span><br><span class="line">                        writer.writerow([file_name, file_code])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果文本文件不存在，将标签设置为-1</span></span><br><span class="line">                    writer.writerow([img_name, <span class="string">&#x27;-1&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/jianyezeng/Street-View-Character-Recognition">街景字符识别</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> YOLO </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>街景字符识别-ResNet多分类模型</title>
      <link href="blog/%E8%A1%97%E6%99%AF%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB-ResNet%E5%A4%9A%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>blog/%E8%A1%97%E6%99%AF%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB-ResNet%E5%A4%9A%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="街景字符识别-ResNet多分类模型"><a href="#街景字符识别-ResNet多分类模型" class="headerlink" title="街景字符识别-ResNet多分类模型"></a>街景字符识别-ResNet多分类模型</h1><h2 id="背景详情"><a href="#背景详情" class="headerlink" title="背景详情"></a>背景详情</h2><p><strong>赛题链接</strong>：<a href="https://tianchi.aliyun.com/competition/entrance/531795/information">街景字符编码识别<em>学习赛</em>赛题与数据_天池大赛-阿里云天池 (aliyun.com)</a></p><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题来源自Google街景图像中的门牌号数据集（The Street View House Numbers Dataset, SVHN），并根据一定方式采样得到比赛数据集。</p><p>数据集报名后可见并可下载，该数据来自真实场景的门牌号。训练集数据包括3W张照片，验证集数据包括1W张照片，每张照片包括颜色图像和对应的编码类别和具体位置；为了保证比赛的公平性，测试集A包括4W张照片，测试集B包括4W张照片。</p><h4 id="数据集样本展示"><a href="#数据集样本展示" class="headerlink" title="数据集样本展示"></a>数据集样本展示</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307211620050.jpeg" alt="enter image description here"></p><p>需要注意的是本赛题需要选手识别图片中所有的字符，为了降低比赛难度，我们提供了训练集、验证集和测试集中字符的位置框。</p><h4 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h4><p>所有的数据（训练集、验证集和测试集）的标注使用JSON格式，并使用文件名进行索引。如果一个文件中包括多个字符，则使用列表将字段进行组合。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Field</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td style="text-align:center">左上角坐标Y</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">字符高度</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">左上角坐标X</td></tr><tr><td style="text-align:center">width</td><td style="text-align:center">字符宽度</td></tr><tr><td style="text-align:center">label</td><td style="text-align:center">字符编码</td></tr></tbody></table></div><p>注：数据集来源自SVHN，网页链接<a href="http://ufldl.stanford.edu/housenumbers/，并进行匿名处理和噪音处理。">http://ufldl.stanford.edu/housenumbers/，并进行匿名处理和噪音处理。</a></p><h3 id="评测标准"><a href="#评测标准" class="headerlink" title="评测标准"></a>评测标准</h3><p>评价标准为准确率，选手提交结果与实际图片的编码进行对比，以编码整体识别准确率为评价指标，结果越大越好，具体计算公式如下：</p><script type="math/tex; mode=display">score =编码识别正确的数量测试集图片数量/测试集图片数量编码识别正确的数量​</script><h3 id="结果提交"><a href="#结果提交" class="headerlink" title="结果提交"></a>结果提交</h3><p>预测结果的格式与sample_submit.csv中的格式一致，提交文件后缀名为csv。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file_name, file_code</span><br><span class="line">0010000.jpg,451</span><br><span class="line">0010001.jpg,232</span><br><span class="line">0010002.jpg,45</span><br><span class="line">0010003.jpg,67</span><br><span class="line">0010004.jpg,191</span><br><span class="line">0010005.jpg,892</span><br></pre></td></tr></table></figure><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><ol><li><p>对图像进行数据预处理</p><p>作为训练数据的图像大小不一，因此可以使用<code>transfrom</code>将其大小变为一致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([</span><br><span class="line">         transforms.Resize((<span class="number">64</span>, <span class="number">64</span>)),</span><br><span class="line">         transforms.ToTensor(),</span><br><span class="line">     ])</span><br></pre></td></tr></table></figure></li><li><p>对label文件进行数据预处理</p><p>本赛题的label保存在一个<code>json</code>文件中（如下图所示）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307211635885.JPG" alt="json文件示例"></p><p><code>json</code>文件中数据类似于一个字典，字典的键为图像名，字典的值为图像的字段表。由于不同图像中数字个数不同，我们可以对其进行简化，对<code>json</code>文件进行预处理，使每个图像对应label的长度相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_data_processing</span>(<span class="params">read_path,save_path</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(read_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        read_data = json.load(f)</span><br><span class="line">    <span class="keyword">for</span> key,item <span class="keyword">in</span> read_data.items():</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(item[<span class="string">&#x27;label&#x27;</span>]) &lt; <span class="number">5</span>:</span><br><span class="line">            item[<span class="string">&#x27;height&#x27;</span>].append(<span class="number">0</span>)</span><br><span class="line">            item[<span class="string">&#x27;label&#x27;</span>].append(<span class="number">0</span>)</span><br><span class="line">            item[<span class="string">&#x27;left&#x27;</span>].append(<span class="number">0</span>)</span><br><span class="line">            item[<span class="string">&#x27;top&#x27;</span>].append(<span class="number">0</span>)</span><br><span class="line">            item[<span class="string">&#x27;width&#x27;</span>].append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(item[<span class="string">&#x27;label&#x27;</span>]) &gt; <span class="number">5</span>:</span><br><span class="line">            item[<span class="string">&#x27;height&#x27;</span>].pop(-<span class="number">1</span>)</span><br><span class="line">            item[<span class="string">&#x27;label&#x27;</span>].pop(-<span class="number">1</span>)</span><br><span class="line">            item[<span class="string">&#x27;left&#x27;</span>].pop(-<span class="number">1</span>)</span><br><span class="line">            item[<span class="string">&#x27;top&#x27;</span>].pop(-<span class="number">1</span>)</span><br><span class="line">            item[<span class="string">&#x27;width&#x27;</span>].pop(-<span class="number">1</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 转换为 JSON 格式的字符串</span></span><br><span class="line">    json_str = json.dumps(read_data, indent=<span class="number">2</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 将 JSON 字符串写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(save_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json_str)</span><br></pre></td></tr></table></figure></li></ol><h3 id="神经网络搭建"><a href="#神经网络搭建" class="headerlink" title="神经网络搭建"></a>神经网络搭建</h3><p>在这里选择使用预处理过的ResNet50神经网络，并将其最后一层进行替换，以达到微调的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">svhn</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(svhn, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model_conv = models.resnet50(pretrained=<span class="literal">True</span>)</span><br><span class="line">        self.model_conv.avgpool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.model_conv = nn.Sequential(*<span class="built_in">list</span>(self.model_conv.children())[:-<span class="number">1</span>])  <span class="comment"># 去除最后一个fc layer</span></span><br><span class="line">        self.cnn = self.model_conv</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">2048</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">2048</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">2048</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">2048</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc5 = nn.Linear(<span class="number">2048</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, img</span>):</span></span><br><span class="line">        feat = self.cnn(img)</span><br><span class="line">        feat = feat.view(feat.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        c1 = self.fc1(feat)</span><br><span class="line">        c2 = self.fc2(feat)</span><br><span class="line">        c3 = self.fc3(feat)</span><br><span class="line">        c4 = self.fc4(feat)</span><br><span class="line">        c5 = self.fc5(feat)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c1, c2, c3, c4, c5</span><br></pre></td></tr></table></figure><h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>选择的优化器和损失函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), config[<span class="string">&#x27;learning_rate&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h3><p>在得到预测结果后，需要将得到的多个分类结果合并，并将补的0删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">input</span>,name <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="keyword">if</span> device == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.cuda()</span><br><span class="line">    c0,c1,c2,c3,c4 = model(<span class="built_in">input</span>)</span><br><span class="line">    output = np.concatenate([</span><br><span class="line">        c0.data.cpu().numpy(),</span><br><span class="line">        c1.data.cpu().numpy(),</span><br><span class="line">        c2.data.cpu().numpy(),</span><br><span class="line">        c3.data.cpu().numpy(),</span><br><span class="line">        c4.data.cpu().numpy()], axis=<span class="number">1</span>)</span><br><span class="line">    test_pred.append(output)</span><br><span class="line">test_pred = np.vstack(test_pred)</span><br><span class="line">test_predict_label = np.vstack([</span><br><span class="line">    test_pred[:, :<span class="number">11</span>].argmax(<span class="number">1</span>),</span><br><span class="line">    test_pred[:, <span class="number">11</span>:<span class="number">22</span>].argmax(<span class="number">1</span>),</span><br><span class="line">    test_pred[:, <span class="number">22</span>:<span class="number">33</span>].argmax(<span class="number">1</span>),</span><br><span class="line">    test_pred[:, <span class="number">33</span>:<span class="number">44</span>].argmax(<span class="number">1</span>),</span><br><span class="line">    test_pred[:, <span class="number">44</span>:<span class="number">55</span>].argmax(<span class="number">1</span>),</span><br><span class="line">]).T</span><br><span class="line"></span><br><span class="line">test_label_pred = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> test_predict_label:</span><br><span class="line">    test_label_pred.append(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, x[x != <span class="number">10</span>])))</span><br></pre></td></tr></table></figure><h2 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h2><h3 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h3><p>对用于训练集和验证集的图像进行数据增广处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([</span><br><span class="line">        transforms.Resize((<span class="number">80</span>, <span class="number">160</span>)),</span><br><span class="line">        transforms.RandomCrop((<span class="number">64</span>, <span class="number">128</span>)),</span><br><span class="line">        transforms.ColorJitter(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.2</span>),</span><br><span class="line">        transforms.RandomRotation(<span class="number">5</span>),</span><br><span class="line">        <span class="comment">#transforms.Resize((64,64)),</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h3 id="神经网络改进"><a href="#神经网络改进" class="headerlink" title="神经网络改进"></a>神经网络改进</h3><p>对原神经网络进行调整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">svhn</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(svhn, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.model_conv = models.resnet50(pretrained=<span class="literal">True</span>)</span><br><span class="line">        self.model_conv.avgpool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.model_conv = nn.Sequential(*<span class="built_in">list</span>(self.model_conv.children())[:-<span class="number">1</span>])  <span class="comment"># 去除最后一个fc layer</span></span><br><span class="line">        self.cnn = self.model_conv</span><br><span class="line"></span><br><span class="line">        self.hd_fc1 = nn.Linear(<span class="number">2048</span>, <span class="number">128</span>)</span><br><span class="line">        self.hd_fc2 = nn.Linear(<span class="number">2048</span>, <span class="number">128</span>)</span><br><span class="line">        self.hd_fc3 = nn.Linear(<span class="number">2048</span>, <span class="number">128</span>)</span><br><span class="line">        self.hd_fc4 = nn.Linear(<span class="number">2048</span>, <span class="number">128</span>)</span><br><span class="line">        self.hd_fc5 = nn.Linear(<span class="number">2048</span>, <span class="number">128</span>)</span><br><span class="line">        self.dropout_1 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout_2 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout_3 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout_4 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.dropout_5 = nn.Dropout(<span class="number">0.25</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">128</span>, <span class="number">11</span>)</span><br><span class="line">        self.fc5 = nn.Linear(<span class="number">128</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, img</span>):</span></span><br><span class="line">        feat = self.cnn(img)</span><br><span class="line">        feat = feat.view(feat.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        feat1 = self.hd_fc1(feat)</span><br><span class="line">        feat2 = self.hd_fc2(feat)</span><br><span class="line">        feat3 = self.hd_fc3(feat)</span><br><span class="line">        feat4 = self.hd_fc4(feat)</span><br><span class="line">        feat5 = self.hd_fc5(feat)</span><br><span class="line">        feat1 = self.dropout_1(feat1)</span><br><span class="line">        feat2 = self.dropout_2(feat2)</span><br><span class="line">        feat3 = self.dropout_3(feat3)</span><br><span class="line">        feat4 = self.dropout_4(feat4)</span><br><span class="line">        feat5 = self.dropout_5(feat5)</span><br><span class="line"></span><br><span class="line">        c1 = self.fc1(feat1)</span><br><span class="line">        c2 = self.fc2(feat2)</span><br><span class="line">        c3 = self.fc3(feat3)</span><br><span class="line">        c4 = self.fc4(feat4)</span><br><span class="line">        c5 = self.fc5(feat5)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c1, c2, c3, c4, c5</span><br></pre></td></tr></table></figure><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/jianyezeng/Street-View-Character-Recognition">街景字符识别</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> ResNet50 </tag>
            
            <tag> 分类模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用队列实现栈 &amp; 用栈实现队列</title>
      <link href="blog/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%20&amp;%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>blog/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%20&amp;%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="用队列实现栈-amp-用栈实现队列"><a href="#用队列实现栈-amp-用栈实现队列" class="headerlink" title="用队列实现栈 &amp; 用栈实现队列"></a>用队列实现栈 &amp; 用栈实现队列</h1><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><blockquote><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.size() == <span class="number">0</span>) p2.push(x);</span><br><span class="line">        <span class="keyword">else</span> p1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p1.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p2.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                temp = p2.front();</span><br><span class="line">                p1.push(temp);</span><br><span class="line">                p2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = p2.front();</span><br><span class="line">            p2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                temp = p1.front();</span><br><span class="line">                p2.push(temp);</span><br><span class="line">                p1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = p1.front();</span><br><span class="line">            p1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="keyword">this</span>-&gt;pop();</span><br><span class="line">        <span class="keyword">this</span>-&gt;push(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.size()==<span class="number">0</span> &amp;&amp; p2.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            q.push(temp);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="keyword">this</span>-&gt;pop();</span><br><span class="line">        <span class="keyword">this</span>-&gt;push(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一使用了两个队列以实现栈；在此过程中，为空的队列起到备份的作用。在<code>pop()</code>与<code>top()</code>中，将存储元素的队列中元素导入空队列中，只剩下最后一个，即为最后进的元素。</li><li>解二是对解一的优化，仅使用了一个队列即实现了栈的作用。在此过程中，每次都将从队列首端pop出的元素加入尾端，直至最后进入的元素，以实现栈的作用。</li></ol><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;instack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;outstack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        instack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (outstack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!instack.empty())&#123;</span><br><span class="line">                temp = instack.top();</span><br><span class="line">                instack.pop();</span><br><span class="line">                outstack.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = outstack.top();</span><br><span class="line">        outstack.pop();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="keyword">this</span>-&gt;pop();</span><br><span class="line">        outstack.push(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.empty()&amp;&amp;instack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><ol><li>队列先进先出,而栈先进后出，因此可以使用两个栈（一个为输入栈，一个为输出栈）实现队列。<code>push()</code>将新元素直接push进输入栈即可，<code>pop()</code>与<code>peek()</code>较为相近，都是先取输出栈中元素，若输出栈为空，则将输入栈中元素<strong>全部</strong>导入输出栈中；</li><li><code>pop()</code>与<code>peek()</code>功能较为相近，因此可以在<code>peek()</code>中使用<code>pop()</code>，再将被pop的元素加入进去而非重写<code>peek()</code>函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口最大值</title>
      <link href="blog/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>blog/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><blockquote><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            MyQueue()&#123;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!que.empty()&amp;&amp;que.front() &lt; x)&#123;</span><br><span class="line">                    que.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!que.empty()&amp;&amp;que.back() &lt; x)</span><br><span class="line">                    que.pop_back();</span><br><span class="line">                que.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> que.front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">                que.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> que.empty();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>; s&lt;=j; s++)</span><br><span class="line">            que.push(nums[s]);</span><br><span class="line">        result.push_back(que.front());</span><br><span class="line">        i++;j++;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!que.empty()&amp;&amp;que.front()==nums[i<span class="number">-1</span>])</span><br><span class="line">                que.pop(); </span><br><span class="line">            que.push(nums[j]);</span><br><span class="line">            result.push_back(que.front());</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li>这道题使用暴力解法，时间复杂度过高，可以选择使用单调栈进行求解；</li><li>设计单调队列的时候，pop，和push操作要保持如下规则：<ul><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树</title>
      <link href="blog/%E6%A0%91/"/>
      <url>blog/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h1><blockquote><ol><li>树可以为空树，森林也可以为空。</li><li>树是一种递归的数据结构。</li></ol></blockquote><h2 id="结点的度与树的度"><a href="#结点的度与树的度" class="headerlink" title="结点的度与树的度"></a>结点的度与树的度</h2><ul><li>结点的度：树中一个结点的孩子个数称为该结点的度。</li><li><p>树的度：树中结点的最大度数称为树的度。</p><h2 id="分支节点和叶结点"><a href="#分支节点和叶结点" class="headerlink" title="分支节点和叶结点"></a>分支节点和叶结点</h2></li><li><p>度大于0的结点为<strong>分支结点（又称非终端结点）</strong>，在分支结点中，每个结点的分支数就是该结点的度。</p></li><li>度为0（没有孩子结点）的结点称为<strong>叶结点（又称终端结点）</strong>。</li><li><p><strong>根结点并不一定是分支结点，例如只有一个结点的树的根。</strong></p><h2 id="结点的深度、高度和层次"><a href="#结点的深度、高度和层次" class="headerlink" title="结点的深度、高度和层次"></a>结点的深度、高度和层次</h2></li><li><p>结点的层数：从树根开始定义，根结点为第一层，它的孩子是第二层，以此类推。</p></li><li>结点的深度：结点所在的层次。</li><li>树的高度（或深度）：树中结点的最大层数。</li><li><strong>结点的高度</strong>：以该结点为根的子树的高度<h2 id="路径和路径长度、树的路径长度"><a href="#路径和路径长度、树的路径长度" class="headerlink" title="路径和路径长度、树的路径长度"></a>路径和路径长度、树的路径长度</h2>路径： 树中两个结点之间的路径由这两个结点之间所经过的结点序列组成的（包括起始和结束结点）。单向。<br>路径长度：路径上所经过的边的个数。<br><strong>树的路径长度：树根到各个结点的路径长的总和。</strong><h2 id="m叉树与度为m的树"><a href="#m叉树与度为m的树" class="headerlink" title="m叉树与度为m的树"></a>m叉树与度为m的树</h2>| m叉树 | 度为m的树 |<br>| —- | —- |<br>| 每个结点最大度为m |  |<br>| 但是可以没有结点的度为m | 至少有一个结点度为m |<br>| 可以为空树 | 不能为空树，至少m+1个结点 |</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h2><ul><li>满二叉树：高度为h，且有<img src="https://cdn.nlark.com/yuque/__latex/5adb748ba6a6cbdacc0cc14c8b79e09b.svg#card=math&amp;code=2%5Eh-1&amp;id=MowLP" alt="">个结点的二叉树（全满)。</li><li>完全二叉树：高为h，结点数为n，每个结点都与高为h的满二叉树的1-n号结点一一对应。</li><li>二叉排序树：左子树所有结点的关键字均小于根结点，右子树所有结点的关键字均大于根结点，且左右子树也都是二叉排序树。</li><li>二叉平衡树：树中任意一个结点的左右子树高度之差绝对值不超过1。</li><li>正则二叉树：每个分支结点都有2个孩子。<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3>用一组连续的数据单元依次自上而下、自左至右存储完全二叉树（对于一般的二叉树，要补上空结点）上的结点元素。需要的数组长度/存储单元个数等于将这个二叉树变成完全二叉树之后的结点数目，而不是满二叉树。<br>在实际的使用中，可以用0代替不存在的空节点。<br>比较适用于完全二叉树和满二叉树。完全二叉树和满二叉树不需要空出空间，而一般的二叉树则需要存储空结点，空间利用率较低。且一般的二叉树，不能通过2i&lt;=n，2i+1&lt;=n来判断一个结点的左右孩子是否存在。<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><blockquote><p>二叉树的遍历指按某条搜索路径访问树中的每个结点，使<strong>每个结点均被访问一次，且仅被访问一次</strong>。<br>普通二叉树的遍历均需要栈的支持（递归，隐含递归栈；非递归，栈），不包括层次遍历和二叉线索树。</p></blockquote></li></ul><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue(q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(T,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left!=<span class="literal">NULL</span>) EnQueue(p-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>) Enqueue(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先序遍历-根左右"><a href="#先序遍历-根左右" class="headerlink" title="先序遍历 根左右"></a>先序遍历 根左右</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;left);</span><br><span class="line">        PreOrder(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(<span class="built_in">stack</span>); BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p=<span class="built_in">stack</span>.pop();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左根右"><a href="#中序遍历-左根右" class="headerlink" title="中序遍历 左根右"></a>中序遍历 左根右</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;left);</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span>;</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(P)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p=<span class="built_in">stack</span>.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左右根"><a href="#后序遍历-左右根" class="headerlink" title="后序遍历 左右根"></a>后序遍历 左右根</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PreOrder(T-&gt;left);</span><br><span class="line">        PreOrder(T-&gt;right);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span>; BiTree *p=T,*r=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right&amp;&amp;r!=p-&gt;right) p=p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                visit(p);</span><br><span class="line">                r=p;</span><br><span class="line">                p=p-&gt;<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意上述代码中指针r的作用。</strong></p><h2 id="快速得到三种遍历序列的方法"><a href="#快速得到三种遍历序列的方法" class="headerlink" title="快速得到三种遍历序列的方法"></a>快速得到三种遍历序列的方法</h2><p><a href="https://blog.csdn.net/zhuguanlin121/article/details/118215643">数据结构——二叉树先序、中序、后序及层次四种遍历（C语言版）_数据结构二叉树先序中序后序-CSDN博客</a></p><h2 id="遍历序列"><a href="#遍历序列" class="headerlink" title="遍历序列"></a>遍历序列</h2><h3 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h3><p>已知中序序列，再给其他三种遍历序列中的任意一种都可以唯一确定一个二叉树。<br>（即使已知一个二叉树的前序、后序、层次序列，仍可能无法确定唯一的二叉树。例如仅有左子树的1 2 3 4 5，和仅有右子树的1 2 3 4 5）</p><h3 id="前序遍历序列与中序遍历序列的关系"><a href="#前序遍历序列与中序遍历序列的关系" class="headerlink" title="前序遍历序列与中序遍历序列的关系"></a>前序遍历序列与中序遍历序列的关系</h3><p>相当于以前序序列为入栈次序，以中序序列为出栈次序。（因为在使用非递归算法时，进行先序、中序遍历，他们进出栈的顺序是一样的， 先序是先访问再进栈，前序的顺序就是进栈顺序，中序是先出栈再访问，中序的顺序就是出栈的顺序，后序遍历就没有这个说法了，因为后序遍历出栈顺序与前序、中序不同）</p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><blockquote><p>二叉树线索化的实质就是遍历一次二叉树</p></blockquote><h3 id="中序遍历对二叉树线索化"><a href="#中序遍历对二叉树线索化" class="headerlink" title="中序遍历对二叉树线索化"></a>中序遍历对二叉树线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;left,pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;left=pre;</span><br><span class="line">            p-&gt;lflag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;right=p;</span><br><span class="line">            pre-&gt;rflag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InThread(p-&gt;right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ThreadThree pre=<span class="literal">NULL</span>;</span><br><span class="line">    InThread(T,pre);</span><br><span class="line">    pre-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    pre-&gt;rflag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到第一个结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">firstNode</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// if(T==NULL) return NULL;</span></span><br><span class="line">    <span class="comment">// ThreadNode p=T;</span></span><br><span class="line">    <span class="comment">// while(p-&gt;left!=NULL) p=p-&gt;left;</span></span><br><span class="line">    <span class="comment">// return p;</span></span><br><span class="line">    ThreadNode *p=T;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;lflag==<span class="number">0</span>) p=p-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到p结点后继</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FindNext</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rflag==<span class="number">0</span>) <span class="keyword">return</span> firstNode(p-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最后一个结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FindEnd</span><span class="params">(ThreadNode* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(FindNext(p)!=<span class="literal">NULL</span>) p=FindNext(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求结点p前驱</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Findpre</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lflag==<span class="number">0</span>) <span class="keyword">return</span> firstNode(p-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span> <span class="params">(ThreadTree *T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ThreadTree *p=T;</span></span><br><span class="line">    <span class="comment">//p=firstNode(p);</span></span><br><span class="line">    <span class="comment">// while(FindNext(p)!=NULL) &#123;</span></span><br><span class="line">    <span class="comment">//     visit(p);</span></span><br><span class="line">    <span class="comment">//     p=FindNext(p);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(ThreadTree *p=firstNode(T);p!=<span class="literal">NULL</span>;p=FindNext(p)) visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h3><blockquote><p>在没有指向父结点的指针时</p></blockquote><ul><li>找前驱：无法实现。如果一个结点有左孩子，则其左指针指向的是左孩子，没有指针可以指向前驱，而先序遍历中，一个结点的前驱不在以该结点为根的子树中，无法到达。</li><li><p>找后继：若一个结点有左孩子，则左孩子就是其后继，若没有左孩子，但有右孩子，右孩子就是其后继。若没有孩子，则其右指针会指向后继。</p><h3 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h3><blockquote><p>在没有指向父结点的指针时</p></blockquote></li><li><p>找前驱：若该结点没有孩子，则其左指针指向了前驱结点；若该结点有右孩子，则右孩子就是其前驱结点，若该结点没有右孩子但有左孩子，则其左孩子就是前驱结点。</p></li><li>找后继：后序遍历中，某个结点的后继必定不在以该结点为根的子树上，因此不能实现。但若是有了指向父结点的指针，可分为以下几种情况：1.该结点为整个二叉树的根，没有后继结点；2. 该结点为父结点的左孩子，且父结点没有右孩子，则后继为父结点；3.该结点为父结点的右孩子，则后继为父结点；4.该结点为父结点的左孩子且父结点有右子树，则其后继为在父结点的右子树上进行后续遍历的第一个结点。<h3 id="先序-中序-后序线索二叉树对比"><a href="#先序-中序-后序线索二叉树对比" class="headerlink" title="先序/中序/后序线索二叉树对比"></a>先序/中序/后序线索二叉树对比</h3><blockquote><p>在没有指向父结点的指针时</p></blockquote></li></ul><div class="table-container"><table><thead><tr><th></th><th>中序</th><th>先序</th><th>后序</th></tr></thead><tbody><tr><td>找前驱</td><td>√</td><td>×</td><td>√</td></tr><tr><td>找后继</td><td>√</td><td>√</td><td>×</td></tr></tbody></table></div><h1 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><blockquote><p>二叉树也可以用树的存储结构来存储，而树却不能都用二叉树的存储结构来存储。</p></blockquote><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><blockquote><p>也可以用来表示森林，是顺序存储</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722756340402-d0cd834a-6bdc-4b4c-aff0-153fa9faed1c.png#averageHue=%23f6f6f6&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;id=u31d3a15a&amp;originHeight=336&amp;originWidth=772&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=91002&amp;status=done&amp;style=none&amp;taskId=u854b9a83-ec74-48bc-b111-2ed09c68c36&amp;title=" alt="1.png"><br>可以快速找到某个结点的双亲，但求结点的孩子需要遍历整个结构。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><blockquote><p>顺序+链式<br>在定义时需要记录根的位置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span></span><br><span class="line">&#125;CTBox[MAXNUM];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;  <span class="comment">//结点在CTBox的索引</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>* <span class="title">nextChild</span>；</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722756490422-554258a1-1900-4e8f-8a42-015a42fc5faf.png#averageHue=%23f5f5f5&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;height=353&amp;id=u47df9a1e&amp;originHeight=353&amp;originWidth=430&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=48089&amp;status=done&amp;style=none&amp;taskId=u51bc2d6b-d9ab-44f6-8210-32bedca4fec&amp;title=&amp;width=430" alt="1.png"></p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><blockquote><p>二叉链式，每个结点左指针指向第一个孩子，右指针指向下一个兄弟。“左孩子，右兄弟”。<br>找双亲结点较麻烦，可以再加一个指向父结点的parent指针。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722756495842-aaef859a-d66f-4411-a6d8-dee0f959ee45.png#averageHue=%23f4f4f4&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;id=u4b0192de&amp;originHeight=332&amp;originWidth=272&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=32323&amp;status=done&amp;style=none&amp;taskId=ud2c11ca4-54bd-48e8-a24d-0ab141cc4dc&amp;title=" alt="2.png"></p><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>“左孩子，右兄弟”。</p><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><blockquote><p>将森林中各个树的根结点视为兄弟，之后“右兄弟”</p></blockquote><ol><li>先将森林中每个树转换为二叉树；</li><li>转换之后，每个树的右子树必是空的，将第二个树作为第一个树的右子树，第三个树作为第二个树的右子树，依次类推。<h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3>“左孩子，右兄弟”<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722757136107-7377b67e-969c-4ed9-a32f-7ebc596005f5.png#averageHue=%23f7f7f7&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;id=u7008236b&amp;originHeight=339&amp;originWidth=660&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=91842&amp;status=done&amp;style=none&amp;taskId=u754f75c0-6b01-4182-8429-7c1c8baa2c1&amp;title=" alt="1.png"><h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722757206625-48325f36-52eb-4aee-bf5a-7e83436cc69a.png#averageHue=%23dbd9d4&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;id=u77adc7f8&amp;originHeight=325&amp;originWidth=811&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=297594&amp;status=done&amp;style=none&amp;taskId=u3f1e66e9-9986-4a23-b7fb-83e2ac2b833&amp;title=" alt="1.png"><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><blockquote><p>森林的中序遍历也被称为后序遍历</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722757250562-3a4c0b8c-998f-4a6b-8219-7f2a4d6424dc.png#averageHue=%23f7f6f6&amp;clientId=ubbf7e21b-7ae9-4&amp;from=ui&amp;id=u331d2cdd&amp;originHeight=557&amp;originWidth=559&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=214958&amp;status=done&amp;style=none&amp;taskId=ub64c4db6-b2f5-4e02-a094-e540989239c&amp;title=" alt="2.png"></p><h1 id="树与森林的应用"><a href="#树与森林的应用" class="headerlink" title="树与森林的应用"></a>树与森林的应用</h1><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>结点的带权路径长度：从树的根到结点的路径长度与结点的权的乘积。</li><li>WPL：树中所有叶结点带权路径长度之后称为该树的带权路径长度，记为WPL。</li><li><strong>哈夫曼树：</strong>在含有n个带权叶结点的二叉树中，WPL最小的二叉树称为<strong>哈夫曼树，也称最优二叉树</strong>。</li><li>哈夫曼树并不唯一，但WPL必相同且为最优。<h3 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h3><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722758305538-f668c849-2113-4bd6-baec-2cabbdb10dfa.png#averageHue=%23f4f4f3&amp;clientId=u64c3de10-158b-4&amp;from=ui&amp;id=u46a6d3b6&amp;originHeight=663&amp;originWidth=801&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=473954&amp;status=done&amp;style=none&amp;taskId=u4c86e92b-a0d4-4757-ad17-03d602a8640&amp;title=" alt="1.png"><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3>前缀编码：没有一个编码是另一个编码的前缀，这样的编码称为前缀编码。<br>将每个字符作为叶子结点，频次作为权，构造哈夫曼树，即可得到<strong>总长度最短的二进制前缀编码</strong>。（构造之后，每次分支结点往下分别为0，1即可）<br><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722758428448-247aaaf6-1dfd-4099-9d54-7ba29ac394fb.png#averageHue=%23f6f6f6&amp;clientId=u64c3de10-158b-4&amp;from=ui&amp;id=ua535f845&amp;originHeight=235&amp;originWidth=279&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=35143&amp;status=done&amp;style=none&amp;taskId=u3c603ca5-9bff-4850-a038-cc508354762&amp;title=" alt="2.png"><h2 id="并查集存在疑问"><a href="#并查集存在疑问" class="headerlink" title="并查集存在疑问"></a>并查集存在疑问</h2><blockquote><p>并查集是一种简单的集合表示。<br>通常使用树的双亲表示作为并查集的存储结构。数组元素的下标表示元素名，根结点的下标表示集合名，根结点的双亲域为负数（可设置为集合内元素个数的相反数）。<br>Find和Union操作时间复杂度分别为<img src="https://cdn.nlark.com/yuque/__latex/e7a0de808978c3ead6550cd750234ee2.svg#card=math&amp;code=O%28d%29%2CO%281%29&amp;id=bQF0u" alt="">，其中d为集合树的深度，最差为n</p></blockquote></li></ol><h3 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h3><ul><li>判断是否成环</li><li>判断连通性</li><li>Kruskal算法<h3 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h3><h4 id="union操作的优化"><a href="#union操作的优化" class="headerlink" title="union操作的优化"></a>union操作的优化</h4>将小树合并到大树，以此降低最后树的高度。（通常利用根结点的绝对值保存集合树中成员个数，实际应用中，成员数目越多，树越高，因此可以通过根结点绝对值的大小判断小树、大树）<br>通过此方法得到的集合树，树的深度不超过<img src="https://cdn.nlark.com/yuque/__latex/19709490b9480bce4fdc0f6f833dd81c.svg#card=math&amp;code=%5Clfloor%20log_2%20%5Crfloor%2B1%0A&amp;id=CM5bC" alt=""><br><img src="https://cdn.nlark.com/yuque/__latex/9870f0a8a5bbe7daeec15c665ffda11b.svg#card=math&amp;code=O%EF%BC%88log_2n%EF%BC%89&amp;id=T97fA" alt=""><h4 id="find操作的优化"><a href="#find操作的优化" class="headerlink" title="find操作的优化"></a>find操作的优化</h4><img src="https://cdn.nlark.com/yuque/0/2024/png/28866587/1722759373548-5841d63a-0d12-4a6f-b723-0f09d4293a68.png#averageHue=%23e7e7e7&amp;clientId=u0bc60df7-d230-4&amp;from=ui&amp;id=u4300e688&amp;originHeight=378&amp;originWidth=845&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=183722&amp;status=done&amp;style=none&amp;taskId=u2cd2b196-a44f-4202-9e9f-9dc24be30f9&amp;title=" alt="1.png"><h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4>|  | 原本 | Union优化 | 压缩路径优化 |<br>| —- | —- | —- | —- |<br>| Find操作 | <img src="https://cdn.nlark.com/yuque/__latex/f3ffbd17c923e0f5ef4d09ed649c0839.svg#card=math&amp;code=O%EF%BC%88n%0A%EF%BC%89&amp;id=GcViT" alt=""> | <img src="https://cdn.nlark.com/yuque/__latex/9870f0a8a5bbe7daeec15c665ffda11b.svg#card=math&amp;code=O%EF%BC%88log_2n%EF%BC%89&amp;id=of0Ur" alt=""> | <img src="https://cdn.nlark.com/yuque/__latex/f7d20b7d83762dde9ce94d0bfab3621c.svg#card=math&amp;code=O%28%5Calpha%28n%0A%29%29&amp;id=bfxZS" alt=""> |<br>| 将n个独立元素Union成一个集合 | <img src="https://cdn.nlark.com/yuque/__latex/8a567b09709a43f60b6373fcd8bade77.svg#card=math&amp;code=O%EF%BC%88n%5E2%EF%BC%89&amp;id=e90Hy" alt=""> | <img src="https://cdn.nlark.com/yuque/__latex/a16a25c92069824a9896f7ba6485fc7a.svg#card=math&amp;code=O%EF%BC%88n%0Alog_2n%EF%BC%89&amp;id=yUgHG" alt=""> | <img src="https://cdn.nlark.com/yuque/__latex/a28f1e9245099c5b10577a501b99e588.svg#card=math&amp;code=O%EF%BC%88n%5Calpha%28n%29%EF%BC%89&amp;id=D82yw" alt=""> |</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>blog/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p>示例 1：</p><p>输入：s = “()”<br>输出：true</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;<span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">&#x27;(&#x27;</span> || s[i]==<span class="string">&#x27;[&#x27;</span> || s[i]==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">stack</span>.top()==<span class="string">&#x27;(&#x27;</span>) <span class="built_in">stack</span>.pop();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">stack</span>.top()==<span class="string">&#x27;[&#x27;</span>) <span class="built_in">stack</span>.pop();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">stack</span>.top()==<span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">stack</span>.pop();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>对于这道题，我们需要注意以下三种错误情况：</p><ul><li>“[{]}”，即左右两边括号都没有多余，但不能匹配上；</li><li>“{}[“，即右边括号多余，不能匹配；</li><li>“](){}”，即左边括号多余，不能匹配</li></ul><p>我们可以遍历字符串，将左边括号均放入栈中，对于右边括号，若栈顶没有左边括号，或栈顶的左边括号不能与之匹配，则说明是false，否则将此时栈顶的左边括号弹出；遍历结束后，若栈不为空，则说明有多余的左边括号，仍为false。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前 K 个高频元素</title>
      <link href="blog/%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>blog/%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p><p>示例 2:</p><p>输入: nums = [1], k = 1<br>输出: [1]</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.find(nums[i])!=mp.end())</span><br><span class="line">                mp[nums[i]]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mp[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)</span><br><span class="line">                pq.push(i.second);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second &gt; pq.top())&#123; </span><br><span class="line">                    pq.pop();</span><br><span class="line">                    pq.push(i.second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second &gt;= pq.top())</span><br><span class="line">                result.push_back(i.first);</span><br><span class="line">            <span class="keyword">if</span>(result.size()==k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>本题的思路如下：</p><ol><li>使用哈希表存储各元素出现次数；</li><li>对各元素出现次数进行排序；</li><li>将排序最大的k个元素取出；</li></ol><p>在第二、三步可以维护一个长度为k的优先队列用于排序和取得最大的k个元素。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除字符串中的所有相邻重复项</title>
      <link href="blog/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>blog/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p><blockquote><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">stack</span>.empty()&amp;&amp;<span class="built_in">stack</span>.top()==s[i])</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">stack</span>.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            str.insert(str.begin(),temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这道题使用栈实现了匹配相邻元素，当匹配成功时，删除被匹配的栈顶元素，否则加入栈；需要注意，从栈中取出得到的字符串时，需要进行反转或头插法。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Pansharpening</title>
      <link href="blog/%E5%88%9D%E8%AF%86Pansharpening/"/>
      <url>blog/%E5%88%9D%E8%AF%86Pansharpening/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初识Pansharpening"><a href="#初识Pansharpening" class="headerlink" title="初识Pansharpening"></a>初识Pansharpening</h1><h2 id="什么是Pansharpening？"><a href="#什么是Pansharpening？" class="headerlink" title="什么是Pansharpening？"></a>什么是Pansharpening？</h2><blockquote><p>Pansharpening即全色锐化（遥感图像全色锐化）。</p></blockquote><p>通过遥感卫星搭载的不同传感器可以获得同一目标区域的<strong>单波段高空间分辨率全色图像</strong>（Panchromatic， <strong>PAN</strong>）与<strong>低空间分辨率的多光谱图像 </strong>（ low-spatial resolution multispectral，<strong>LRMS</strong>）。通过将这两种图像进行融合，即可得到更优质的<strong>高空间分辨率多光谱图像</strong>（highspatial resolution multispectral，<strong>HRMS</strong>），这个过程就是<strong>遥感图像全色锐化</strong>（<strong>Pansharpening</strong>）。</p><p> <img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202309111812011.JPG" alt="Pansharpening过程示例"></p><h2 id="进行Pansharpening有哪些方法？"><a href="#进行Pansharpening有哪些方法？" class="headerlink" title="进行Pansharpening有哪些方法？"></a>进行Pansharpening有哪些方法？</h2><h3 id="基于比例的方法"><a href="#基于比例的方法" class="headerlink" title="基于比例的方法"></a>基于比例的方法</h3><p>这类方法通过按比例将低分辨率的多光谱波段与高分辨率的全色波段相乘，以增强彩色和细节信息。Brovey变换就是基于比例的方法之一，它将多光谱波段进行加权调整后与全色波段相乘。</p><p>Brovey 变换基于光谱建模，开发该变换的目的在于提高数据直方图高端和低端的视觉对比度。 该变换所采用的方法将各个重采样的多光谱像素乘以相应全色像素亮度与所有多光谱亮度总和的比值。 假定全色图像所跨越的光谱范围与多光谱通道覆盖的范围相同。</p><p>在 Brovey 变换中，常规方程使用红色、绿色和蓝色 (RGB)，并且使用全色波段作为输入来输出新的红色、绿色和蓝色波段，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Red_out &#x3D; Red_in &#x2F; [(blue_in + green_in + red_in) * Pan]</span><br></pre></td></tr></table></figure><p>但是，通过使用权重和近红外波段（可用时），为各波段校正的方程变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNF &#x3D; (P - IW * I) &#x2F; (RW * R + GW * G + BW * B) Red_out &#x3D; R * DNF Green_out &#x3D; G * DNF Blue_out &#x3D; B * DNF Infrared_out &#x3D; I * DNF</span><br></pre></td></tr></table></figure><p>其中输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P &#x3D; 全色图像 R &#x3D; 红色波段 G &#x3D; 绿色波段 B &#x3D; 蓝色波段 I &#x3D; 近红外 W &#x3D; 权重</span><br></pre></td></tr></table></figure><h3 id="变换域方法"><a href="#变换域方法" class="headerlink" title="变换域方法"></a>变换域方法</h3><p>将彩色图像从一个颜色空间转换到另一个颜色空间，然后在新颜色空间中进行处理。常见的变换域方法包括IHS变换、PCA变换和Wavelet变换。IHS变换将彩色图像分解为亮度、色调和饱和度三个分量，将Pansharpening过程中可以用全色图像替代亮度分量后再进行反变换。PCA变换通过主成分分析找出具有最大变化的主成分，并与全色图像相结合。Wavelet变换在小波域中进行分解和重构，以实现图像增强。</p><h3 id="基于模型的方法"><a href="#基于模型的方法" class="headerlink" title="基于模型的方法"></a>基于模型的方法</h3><p>使用数学模型来描述图像的统计特性和空间关系，进而实现图像融合。例如，基于多尺度Retinex理论的方法利用局部对比度增益模型来增强图像的细节和对比度。基于多尺度Retinex理论的方法详细内容可以参考 <a href="https://blog.csdn.net/qq_43743037/article/details/108580741">多尺度图像增强Retinex相关算法学习及实现_retinex算法_J先生x的博客-CSDN博客</a></p><h3 id="基于深度学习的方法"><a href="#基于深度学习的方法" class="headerlink" title="基于深度学习的方法"></a>基于深度学习的方法</h3><p>这类方法使用深度神经网络来学习多光谱和全色图像之间的非线性映射关系。通过训练网络，可以实现高质量的Pansharpening结果(具体方法可见博客内相关内容)。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://liangjiandeng.github.io/papers/2022/deng-jig2022.pdf">遥感图像全色锐化的卷积神经网络方法研究进展 ,邓良剑，冉燃，吴潇，张添敬</a></p><p>[2] <a href="https://doc.arcgis.com/zh-cn/arcgis-online/analyze/fundamentals-of-pan-sharpening-pro.htm">全色锐化的基础知识—ArcGIS Online | 文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Pansharpening </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pansharpening </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度&amp;&amp;二叉树的最小深度</title>
      <link href="blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6&amp;%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6&amp;%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二叉树的最大深度-amp-amp-二叉树的最小深度"><a href="#二叉树的最大深度-amp-amp-二叉树的最小深度" class="headerlink" title="二叉树的最大深度&amp;&amp;二叉树的最小深度"></a>二叉树的最大深度&amp;&amp;二叉树的最小深度</h1><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt;que;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        que.push(cur);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(que.front()-&gt;left!=<span class="literal">nullptr</span>) que.push(que.front()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(que.front()-&gt;right!=<span class="literal">nullptr</span>) que.push(que.front()-&gt;right);</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li>解一使用了层序遍历，每遍历一层，深度+1；</li><li>解二使用了递归，树的深度即根节点的高度=1（根节点所在的层）+左右子树中较高的子树高度。</li></ol><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><h4 id="解一-1"><a href="#解一-1" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;left==<span class="literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="literal">nullptr</span>? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count1 = root-&gt;left!=<span class="literal">nullptr</span>? minDepth(root-&gt;left):INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> count2 = root-&gt;right!=<span class="literal">nullptr</span>? minDepth(root-&gt;right):INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+min(count1,count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二-1"><a href="#解二-1" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层序遍历1&amp;2</title>
      <link href="blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%861&amp;2/"/>
      <url>blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%861&amp;2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二叉树的层序遍历1-amp-2"><a href="#二叉树的层序遍历1-amp-2" class="headerlink" title="二叉树的层序遍历1&amp;2"></a>二叉树的层序遍历1&amp;2</h1><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。 </p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt;que;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt;alevel;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;aline;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">                cur = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                aline.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>) alevel.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>) alevel.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(aline);</span><br><span class="line">            aline.clear();</span><br><span class="line">            <span class="keyword">while</span>(!alevel.empty())&#123;</span><br><span class="line">                que.push(alevel.front());</span><br><span class="line">                alevel.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一使用一个vector存储每一个层次的结果，用一个queue存储下一层节点。</li><li>解二在存储上一层val的同时，将下一层节点加入queque中。</li></ol><h2 id="二叉树的层次遍历2"><a href="#二叉树的层次遍历2" class="headerlink" title="二叉树的层次遍历2"></a>二叉树的层次遍历2</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II - 力扣（LeetCode）</a></p><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></blockquote><p>将上述代码得到的result进行翻转即可：</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用matplotlib进行绘图时标签上中文无法正常显示的问题</title>
      <link href="blog/Python%E4%BD%BF%E7%94%A8matplotlib%E7%BB%98%E5%9B%BE%E6%97%B6%E6%A0%87%E7%AD%BE%E4%B8%8A%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>blog/Python%E4%BD%BF%E7%94%A8matplotlib%E7%BB%98%E5%9B%BE%E6%97%B6%E6%A0%87%E7%AD%BE%E4%B8%8A%E4%B8%AD%E6%96%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用matplotlib进行绘图时标签上中文无法正常显示的问题"><a href="#使用matplotlib进行绘图时标签上中文无法正常显示的问题" class="headerlink" title="使用matplotlib进行绘图时标签上中文无法正常显示的问题"></a>使用matplotlib进行绘图时标签上中文无法正常显示的问题</h1><h2 id="bug示例"><a href="#bug示例" class="headerlink" title="bug示例"></a>bug示例</h2><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307181547572.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在图表代码前加入以下代码行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307181547554.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 注意：把这行代码加入在使用matplotlib内置样式代码后，否则设置会被覆盖。</p><blockquote><p>SimHei ： 中文黑体<br> Kaiti ：中文楷体<br> Lisu ：中文隶书<br> FangSong ： 中文仿宋<br> YouYuan ： 中文幼圆<br> STSong ： 华文宋体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT甲级 1001 A+B Format</title>
      <link href="blog/PAT%E7%94%B2%E7%BA%A7%201001%20A+B%20Format/"/>
      <url>blog/PAT%E7%94%B2%E7%BA%A7%201001%20A+B%20Format/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PAT甲级-1001-A-B-Format"><a href="#PAT甲级-1001-A-B-Format" class="headerlink" title="PAT甲级 1001 A+B Format"></a>PAT甲级 1001 A+B Format</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805528788582400?type=7&amp;page=0">PTA | 程序设计类实验辅助教学平台 (pintia.cn)</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><p>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −106≤<em>a</em>,<em>b</em>≤106. The numbers are separated by a space.</p><p>Output Specification:</p><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><p>Sample Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1000000 9</span><br></pre></td></tr></table></figure><p>Sample Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-999,991</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a,b;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">long</span> temp = a+b;</span><br><span class="line">    <span class="built_in">string</span> str = to_string(temp);</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        ss&lt;&lt;str[<span class="number">0</span>];</span><br><span class="line">        str.erase(str.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a-b%<span class="number">3</span>)%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; i != str.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            ss &lt;&lt; str[i] &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> ss &lt;&lt; str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nums1[p1+p2+1] = nums2[p2--]</title>
      <link href="blog/nums1%5Bp1+p2+1%5D%20=%20nums2%5Bp2--%5D/"/>
      <url>blog/nums1%5Bp1+p2+1%5D%20=%20nums2%5Bp2--%5D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="nums1-p1-p2-1-nums2-p2—"><a href="#nums1-p1-p2-1-nums2-p2—" class="headerlink" title="nums1[p1+p2+1] = nums2[p2—]"></a>nums1[p1+p2+1] = nums2[p2—]</h1><p>今天在做一道leetcode简单题时，遇到了一个bug。</p><p><a href="https://leetcode.cn/problems/merge-sorted-array/">题目链接</a></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202308132315852.JPG" alt="执行出错"></p><p><strong>代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 &#x3D; m-1;</span><br><span class="line">        int p2 &#x3D; n-1;</span><br><span class="line">        while(p1&gt;&#x3D;0 &amp;&amp; p2&gt;&#x3D;0)&#123;</span><br><span class="line">            if (nums1[p1]&lt;&#x3D;nums2[p2]) &#123;</span><br><span class="line">                nums1[p1+p2+1] &#x3D; nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                nums1[p1+p2+1] &#x3D; nums1[p1--];</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        while (p2&gt;&#x3D;0) &#123;</span><br><span class="line">            nums1[p2] &#x3D; nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="bug原因"><a href="#bug原因" class="headerlink" title="bug原因"></a>bug原因</h2><p>​    对指针、数组或容器的访问超出其范围,或者使用了无效的地址。知道了bug产生的原因，接下来开始检查nums1和nums2的访问。然而，检查了好多遍，感觉好像也没错啊。每次减到-1，就会停止循环，不会继续访问了，怎么会访问到无效地址呢？遇事不决看题解。发现题解中的代码与我的代码似乎只有一个地方有点不同一样：</p><p>​                                                    <strong>错误代码：    nums1[p1+p2+1] = nums2[p2—];</strong></p><p>​                                                    <strong>正确代码： nums1[p1+p2+1] = nums2[p2]; p2—；</strong></p><p>​    又开始疑惑了，<code>p2--</code>不是先使用了p2的值，再去赋值吗？为什么这两种情况的结果会出现不同呢？再认真看一下这个代码。原来，问题正是出在这个顺序上。在错误代码中，<code>p2</code>的值首先被使用访问<code>nums2</code>的对应元素，之后<code>p2</code>减1，在这之后，<code>nums1[p1+p2+1]</code>再次使用了<code>p2</code>，但是这个<code>p2</code>已经是-1后的了，因此出现了bug。在错误代码中，将<code>nums1[p1+p2+1]</code>更改为<code>nums1[p1+p2+2]</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span> &amp;&amp; p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1]&lt;=nums2[p2]) &#123;</span><br><span class="line">                nums1[p1+p2+<span class="number">2</span>] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p1+p2+<span class="number">2</span>] = nums1[p1--];</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (p2&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p1+p2+<span class="number">2</span>] = nums2[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后运行代码：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202308132331332.png" alt="通过！"></p><p>成功解决了这个小bug！</p>]]></content>
      
      
      <categories>
          
          <category> bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装VMware Tools选项显示灰色</title>
      <link href="blog/%E5%AE%89%E8%A3%85VMware%20Tools%E9%80%89%E9%A1%B9%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/"/>
      <url>blog/%E5%AE%89%E8%A3%85VMware%20Tools%E9%80%89%E9%A1%B9%E6%98%BE%E7%A4%BA%E7%81%B0%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装VMware-Tools选项显示灰色"><a href="#安装VMware-Tools选项显示灰色" class="headerlink" title="安装VMware Tools选项显示灰色"></a>安装VMware Tools选项显示灰色</h1><p>最近在用VMware装虚拟机玩，在安装VMware Tools时出现了一个小问题：<code>安装VMware Tools</code>选项是灰色的，无法进行安装。</p><p>此问题的解决方法如下：</p><ol><li>关闭当前虚拟机（注意是关闭，而非挂起哦）；</li><li>打开<code>编辑虚拟机设置</code>选项；</li><li>将<code>软盘</code>、<code>CD/DVD(SATA)</code>、<code>CD/DVD 2(SATA)</code>中<code>连接</code>均选为<code>使用物理驱动器</code>，之后再重启虚拟机，就可以看到<code>安装VMware Tools</code>选项可以正常使用了。</li></ol><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307131613652.JPG" alt="虚拟机设置中软盘、CD/DVD、CD/DVD 2"></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307131614423.PNG" alt="设置为使用物理驱动器"></p>]]></content>
      
      
      <categories>
          
          <category> bugs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> VMware安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统课程设计</title>
      <link href="blog/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>blog/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信号与系统课程设计"><a href="#信号与系统课程设计" class="headerlink" title="信号与系统课程设计"></a>信号与系统课程设计</h1><p>[TOC]</p><h2 id="图像处理-平滑、锐化与边缘提取"><a href="#图像处理-平滑、锐化与边缘提取" class="headerlink" title="图像处理(平滑、锐化与边缘提取)"></a>图像处理(平滑、锐化与边缘提取)</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>图像处理(image processing)，用计算机对图像进行分析，以达到所需结果的技术。又称影像处理。图像处理一般指数字图像处理。数字图像是指用工业相机、摄像机、扫描仪等设备经过拍摄得到的一个大的二维数组，该数组的元素称为像素，其值称为灰度值。图像处理技术一般包括图像压缩，增强和复原，匹配、描述和识别3个部分。</p><p>空间滤波是一种采用滤波处理的影像增强方法。目的是改善影像质量，包括去除高频噪声与干扰，及影像边缘增强、线性增强以及去模糊等。平滑和锐化滤波器是处理数字图像的常用方法。</p><p>平滑的主要目的是减少图像中的噪声。锐化的主要目的是突出图像中的细节或增强已经模糊的细节。</p><h3 id="图像平滑处理"><a href="#图像平滑处理" class="headerlink" title="图像平滑处理"></a>图像平滑处理</h3><p>图像在获取、传输的过程中，可能会受到干扰的影响，会产生噪声，噪声是一种出错了的信号，噪声会造成图像粗糙，需要我们对图像进行平滑处理，保留有用的信号。</p><p>在imgpr1.m，imgpr2.m中我们使用均值滤波、高斯滤波、中值滤波对img1，img2进行了平滑处理，分别得到三种结果，由于img1中存在椒盐干扰，因此中值滤波效果最好，对于img2则三种效果相似。</p><p>img1（最左为原图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232320952.png" alt="image-20230523232030867"></p><p>img2（最左为原图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232319447.png" alt="image-20230523231924542"></p><h3 id="图像锐化处理"><a href="#图像锐化处理" class="headerlink" title="图像锐化处理"></a>图像锐化处理</h3><p>图像锐化<em>(image sharpening)</em>是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，图像锐化是为了突出图像上地物的边缘、轮廓，或某些线性目标要素的特征。这种滤波方法提高了地物边缘与周围像元之间的反差，因此也被称为边缘增强。</p><p>图像平滑往往使图像中的边界、轮廓变得模糊，为了减少这类不利效果的影响，这就需要利用图像锐化技术，使图像的边缘变的清晰。</p><p>公式推导：</p><script type="math/tex; mode=display">▽^2f=▽f(x+1)−▽f(x)\\▽f(x)=f(x+1)−f(x)\\</script><p>可得:    </p><script type="math/tex; mode=display">f(x)=f(x+1)−▽f(x)\\</script><p>则：</p><script type="math/tex; mode=display">f(x)=f(x+1)−▽f(x)+▽^2f(x)\\</script><p>那么锐化后的图像即为:</p><script type="math/tex; mode=display">g(x)=f(x+1)−▽f(x)+k▽^2f(x)\\</script><p>在不考虑精确度的情况下:</p><script type="math/tex; mode=display">g(x)=f(x)+k▽^2f(x)</script><p>在imgpr3.m中我们使用两种不同卷积核对img3进行了锐化处理（最左为原图）：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232320462.png" alt="image-20230523232048348"></p><h3 id="图像边缘提取"><a href="#图像边缘提取" class="headerlink" title="图像边缘提取"></a>图像边缘提取</h3><p>在imgpr4.m中，我们利用高斯滤波和canny算子，对img2进行了边缘提取：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232321314.png" alt="image-20230523232154263"></p><h2 id="求图像中细胞平均半径"><a href="#求图像中细胞平均半径" class="headerlink" title="求图像中细胞平均半径"></a>求图像中细胞平均半径</h2><h3 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026738.jpeg" alt="image"></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>图中很明显存在椒盐噪声（黑白点），因此首先使用中值滤波进行处理。</p><p>处理后：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026731.jpeg" alt="p1"></p><h4 id="高斯低通滤波与巴特沃斯低通滤波"><a href="#高斯低通滤波与巴特沃斯低通滤波" class="headerlink" title="高斯低通滤波与巴特沃斯低通滤波"></a>高斯低通滤波与巴特沃斯低通滤波</h4><p>之后使用傅里叶变换，将其转换到频域上，再进行后续操作：</p><ul><li>高斯低通滤波</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 读入原始图像</span></span><br><span class="line">img = imread(<span class="string">&#x27;p1.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对原始图像进行傅里叶变换</span></span><br><span class="line">F = fftshift(fft2(img));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 高斯低通滤波器参数</span></span><br><span class="line">D0 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构造高斯低通滤波器</span></span><br><span class="line">[x, y] = <span class="built_in">meshgrid</span>(-(<span class="built_in">size</span>(img,<span class="number">1</span>)/<span class="number">2</span>):(<span class="built_in">size</span>(img,<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>), -(<span class="built_in">size</span>(img,<span class="number">2</span>)/<span class="number">2</span>):(<span class="built_in">size</span>(img,<span class="number">2</span>)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">dist = <span class="built_in">sqrt</span>(x.^<span class="number">2</span> + y.^<span class="number">2</span>);</span><br><span class="line">gauss_filter = <span class="built_in">exp</span>(-dist.^<span class="number">2.</span>/(<span class="number">2</span>*D0^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 滤波</span></span><br><span class="line">filtered_F = F .* gauss_filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 反变换</span></span><br><span class="line">filtered_img = uint8(<span class="built_in">real</span>(ifft2(ifftshift(filtered_F))));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示滤波前后的图像</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);imshow(img);title(<span class="string">&#x27;原始图像&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);imshow(filtered_img);title(<span class="string">&#x27;滤波后的图像&#x27;</span>);</span><br></pre></td></tr></table></figure><p>得到图像<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026807.png" alt="untitled"></p><ul><li>巴特沃斯低通滤波</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">p1 = imread(<span class="string">&#x27;p1.jpg&#x27;</span>);</span><br><span class="line">F=double(p1);<span class="comment">%数据类型转换，MATLAB不支特图像的无符号整型的i计算</span></span><br><span class="line">G = fft2(F);<span class="comment">%傅立叶变换</span></span><br><span class="line">G=fftshift(G);<span class="comment">%转换数据矩阵</span></span><br><span class="line">[M,N]=<span class="built_in">size</span>(G);</span><br><span class="line">nn=<span class="number">2</span>;<span class="comment">%二阶巴特沃斯(Butterworth)高通滤波器</span></span><br><span class="line">d0=<span class="number">30</span>;</span><br><span class="line">m=<span class="built_in">fix</span> (M/<span class="number">2</span>);n=<span class="built_in">fix</span>(N/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:M</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">        d=<span class="built_in">sqrt</span>((<span class="built_in">i</span>-m)^<span class="number">2</span>+(<span class="built_in">j</span>-n)^<span class="number">2</span>);</span><br><span class="line">        h=<span class="number">1</span>/(<span class="number">1</span>+<span class="number">0.414</span>*(d/d0)^(<span class="number">2</span>*nn));<span class="comment">%i计算传递函数</span></span><br><span class="line">        result(<span class="built_in">i</span>,<span class="built_in">j</span>) = h*G(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">result=ifftshift(result);</span><br><span class="line">Y2=ifft2(result);</span><br><span class="line">Y3=uint8(<span class="built_in">real</span>(Y2));</span><br><span class="line">subplot(<span class="number">121</span>),imshow(p1),title(<span class="string">&#x27;原图像&#x27;</span>);<span class="comment">%滤波后图像显示</span></span><br><span class="line">subplot(<span class="number">122</span>),imshow(Y3),title(<span class="string">&#x27;巴特沃斯低通滤波后图像&#x27;</span>);<span class="comment">%滤波后图像显示</span></span><br><span class="line"></span><br><span class="line">P_signal = sum(p1(:).^<span class="number">2</span>);</span><br><span class="line">P_noise_denoised = sum((Y3(:) - p1(:)).^<span class="number">2</span>);</span><br><span class="line">SNR_denoised = <span class="number">10</span>*<span class="built_in">log10</span>(P_signal/P_noise_denoised);</span><br><span class="line"><span class="built_in">disp</span>(SNR_denoised);</span><br></pre></td></tr></table></figure><p>得到图像<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026799.png" alt="untitled"></p><ul><li><p>两种滤波的比较</p><p>| 滤波   | 高斯低通滤波 | 巴特沃斯低通滤波 |<br>| ——— | —————— | ———————— |<br>| 信噪比 | 6.3678       | 5.1209           |</p><p>因此选择高斯低通滤波，之后进行逆傅里叶变换</p></li></ul><h4 id="其余预处理"><a href="#其余预处理" class="headerlink" title="其余预处理"></a>其余预处理</h4><ol><li>灰度化</li><li>直方图均衡化</li><li>低帽变换</li><li>调节灰度对比</li><li>二值化</li><li>形态学操作<ul><li>开操作</li><li>闭操作</li></ul></li></ol><h3 id="计算细胞半径"><a href="#计算细胞半径" class="headerlink" title="计算细胞半径"></a>计算细胞半径</h3><h4 id="hough圆形检测"><a href="#hough圆形检测" class="headerlink" title="hough圆形检测"></a>hough圆形检测</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 使用Hough变换进行圆形检测</span></span><br><span class="line">[centers, radii] = imfindcircles(BW3,[<span class="number">4</span>, <span class="number">20</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算细胞平均半径</span></span><br><span class="line">avgRadius = <span class="built_in">mean</span>(radii);</span><br><span class="line">sigma = std(radii);</span><br><span class="line">lower_threshold = avgRadius - <span class="number">2</span> * sigma;</span><br><span class="line">upper_threshold = avgRadius + <span class="number">2</span> * sigma;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 找到位于阈值内的所有元素</span></span><br><span class="line">idx = <span class="built_in">find</span>(radii &gt;= lower_threshold &amp; radii &lt;= upper_threshold);</span><br><span class="line">radii = radii(idx);</span><br><span class="line">centers = centers(idx,:);</span><br><span class="line">avgRadius = <span class="built_in">mean</span>(radii);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="comment">% 显示原始图像和检测结果</span></span><br><span class="line">imshow(p2); <span class="built_in">hold</span> on;</span><br><span class="line">h = viscircles(centers, radii,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">title([<span class="string">&#x27;Average cell radius: &#x27;</span>, num2str(avgRadius)]);</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026826.png" alt="untitled"></p><h4 id="bwlabel函数求半径"><a href="#bwlabel函数求半径" class="headerlink" title="bwlabel函数求半径"></a>bwlabel函数求半径</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 连通区域分析，计算每个细胞的面积和周长，并计算等效直径</span></span><br><span class="line">[L, num] = bwlabel(BW3);</span><br><span class="line">stats = regionprops(L, &#123;<span class="string">&#x27;Area&#x27;</span>, <span class="string">&#x27;Perimeter&#x27;</span>&#125;);</span><br><span class="line">diameters = <span class="built_in">zeros</span>(num, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : num</span><br><span class="line">    diameters(<span class="built_in">i</span>) = <span class="number">2</span> * <span class="built_in">sqrt</span>(stats(<span class="built_in">i</span>).Area / <span class="built_in">pi</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">boundaries = bwboundaries(BW3);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;The average diameter of cells is: &#x27;</span>, num2str(avg_diameter)]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="comment">% 画出每个细胞的轮廓</span></span><br><span class="line">imshow(BW3);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(boundaries)</span><br><span class="line">    boundary = boundaries&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    <span class="built_in">plot</span>(boundary(:,<span class="number">2</span>), boundary(:,<span class="number">1</span>),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>结果如图所示</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026872.png" alt="untitled"></p><h4 id="两种结果对比"><a href="#两种结果对比" class="headerlink" title="两种结果对比"></a>两种结果对比</h4><ol><li>hough圆形检测法，对于部分形状不是圆的细胞，可能并不适用；</li><li>bwlabel函数求半径法，由于很多细胞重叠在一起，导致被认定为一个细胞，因此结果比较差。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于K-means算法的出行用户的分区</title>
      <link href="blog/%E5%9F%BA%E4%BA%8EK-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E8%A1%8C%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E5%8C%BA/"/>
      <url>blog/%E5%9F%BA%E4%BA%8EK-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E8%A1%8C%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于K-means算法的出行用户的分区"><a href="#基于K-means算法的出行用户的分区" class="headerlink" title="基于K-means算法的出行用户的分区"></a>基于K-means算法的出行用户的分区</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某个打车平台的数据中心目前有 1000 位正在等待出行的顾客.现在已知每位顾客的出发地点的经度、纬度，到达地点的经度、纬度.这些数据保存在 data_customer.txt 文本文件中(位置数据是虚拟数据,并不一定完全符合实际).每行代表一个顾客的信息,依次表示出发地点经度、出发地点纬度、到达地点经度、到达地点纬度. 如果要把顾客出发地所在区域分为 10 个分区管理,请问每位顾客应分别分在哪个区,每个区的中心在哪里。</p><p><a href="https://camo.githubusercontent.com/7d6e21915df34fabe4a5c8a7d5d96de2bb1ac9a5561a3d1f2350b05dbabd1b74/68747470733a2f2f7a6a79696d6167652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f3230323330363230303035393430302e706e67"><img src="https://camo.githubusercontent.com/7d6e21915df34fabe4a5c8a7d5d96de2bb1ac9a5561a3d1f2350b05dbabd1b74/68747470733a2f2f7a6a79696d6167652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f3230323330363230303035393430302e706e67" alt="QQ截图20230620005735"></a></p><h2 id="聚类结果展示"><a href="#聚类结果展示" class="headerlink" title="聚类结果展示"></a>聚类结果展示</h2><p><a href="https://github.com/jianyezeng/some-practice-and-small-course-labs-or-assignments/blob/main/基于K-means算法的出行用户的分区/User_Partitions.m">代码与数据下载</a></p><p>基于K-means算法实现（matlab），效果如图所示：</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307021426962.png" alt="结果"></h1><h2 id="代码实现（matlab）"><a href="#代码实现（matlab）" class="headerlink" title="代码实现（matlab）"></a>代码实现（matlab）</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;data_customer.txt&#x27;</span>; </span><br><span class="line">data = importdata(filename); </span><br><span class="line">location = [data(:,<span class="number">1</span>:<span class="number">2</span>);data(:,<span class="number">3</span>:<span class="number">4</span>)];</span><br><span class="line">x = location(:,<span class="number">1</span>);</span><br><span class="line">y = location(:,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x,y,<span class="number">5</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,[<span class="number">0</span> <span class="number">.255</span> <span class="number">.5</span>]);</span><br><span class="line"></span><br><span class="line">K = <span class="number">10</span>;</span><br><span class="line">[idx, C] = kmeans(location, K,<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">gscatter(location(:,<span class="number">1</span>), location(:,<span class="number">2</span>), idx);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(C(:,<span class="number">1</span>), C(:,<span class="number">2</span>), <span class="string">&#x27;kx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>,<span class="string">&#x27;DisplayName&#x27;</span>, <span class="string">&#x27;聚类中心&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左旋转字符串</title>
      <link href="blog/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>blog/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><blockquote><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">st</span><span class="params">(n,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;n) st[i] = s[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.size()-n) s[i] = s[i+n];</span><br><span class="line">            <span class="keyword">else</span> s[i] = st[i+n-s.size()];</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.begin()+n);</span><br><span class="line">        reverse(s.begin()+n,s.end());</span><br><span class="line">        reverse(s.begin(),s.end());            </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>解一遍历整个字符串，首先将需要旋转至尾部的部分存到新的字符串中，字符串后面的部分前移，当遍历至已经前移过的部位时，将存在新字符串中的需要选择至尾部的部分提取并赋值；</p></li><li><p>解二采用局部反转+整体反转的思路；<strong>具体步骤为</strong>：<strong>反转</strong>区间为 <code>前n</code> 的子串；<strong>反转</strong>区间为<code>n</code> 到<code>末尾</code>的子串；<strong>反转</strong> 整个字符串（如下图所示）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202306141910905.png" alt="1685707897-lpxpas-604020381907e149b88d0892cfb11d0"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出字符串中第一个匹配项的下标</title>
      <link href="blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
      <url>blog/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a>找出字符串中第一个匹配项的下标</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><blockquote><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>示例 1：</p><p>输入：haystack = “sadbutsad”, needle = “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> haystack,<span class="built_in">string</span> needle,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;needle.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num&lt;haystack.length() &amp;&amp; needle[i]==haystack[num]))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;a&lt;haystack.length();a++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[a] == needle[b])&#123;</span><br><span class="line">                result = a;</span><br><span class="line">                flag = judge(haystack, needle, a);</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">return</span> result;</span><br><span class="line">                <span class="keyword">else</span> result = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123; </span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next[needle.size()];</span><br><span class="line">        getNext(next, needle);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.size() - <span class="number">1</span>) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li>解一使用了朴素解法（暴力求解），枚举原字符串的每一个字符进行匹配；时间复杂度为$O(mn)$;</li><li>解二使用了KMP算法进行匹配，每次匹配失败时并不会返回至原字符串的下一个字符进行匹配，而是根据next数组确定要匹配的下一个字符。（KMP算法详见个人博客<code>算法</code>部分）</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="blog/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>blog/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>快乐数定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getsum</span>(<span class="params">n</span>):</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="built_in">sum</span> += (n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">                n = n//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">        record = <span class="built_in">set</span>()</span><br><span class="line">        <span class="built_in">sum</span> = getsum(n)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">sum</span> != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">                record.add(<span class="built_in">sum</span>)</span><br><span class="line">                n = <span class="built_in">sum</span></span><br><span class="line">                <span class="built_in">sum</span> = getsum(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getsum</span>(<span class="params">n</span>):</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="built_in">sum</span> += (n%<span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">                n = n//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">        slow_runner = n</span><br><span class="line">        fast_runner = getsum(n)</span><br><span class="line">        <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">            slow_runner = getsum(slow_runner)</span><br><span class="line">            fast_runner = getsum(getsum(fast_runner))</span><br><span class="line">        <span class="keyword">return</span> fast_runner == <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>对于这道题，结果有三种可能：</p><ul><li>sum出现1</li><li>进入循环</li><li>值越来越大，趋近于无穷大，没有进入循环</li></ul><p>但是经过观察，三位数字最大999，其sum也只是243，之后产生的值均小于等于243，因此不会出现第三种情况；</p></li><li><p>解一使用哈希集合检测循环，当新获得的sum已出现在集合中，则说明发生了循环；</p></li><li><p>解二使用了快慢指针法，当需要检测循环时，就可以使用快慢指针法，快指针速度是慢指针的2倍，因此若发生循环，则两者必定相遇；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的字母异位词</title>
      <link href="blog/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>blog/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a, b = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> a:</span><br><span class="line">                a[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> b:</span><br><span class="line">                b[t[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b[t[i]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        record = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            record[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            record[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> record.count(<span class="number">0</span>) == <span class="number">26</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> a:</span><br><span class="line">                a[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> a:</span><br><span class="line">                a[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a.values():</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一直接将两个字符串的对应信息存储在两个字典中，之后通过判断两个字典是否相同来判断两个字符串是否为字母异位词；</li><li>解二使用了哈希表，二十六个字母分别映射到列表中的一个位置中去，原列表元素全为0，对于第一个字符串，每遍历一个字母，其对应位置的列表元素+1，之后对于第二个字符串，每遍历一个字母，其对应位置的列表元素-1，若最终列表中元素仍全为0，则说明两个字符串为字母异位词；</li><li>受解二的启发，联想到，解一的字典实际上与解二的列表发挥的作用是一致的，因此可以对解一进行改进，如解三所示，利用字典实现了哈希表（与解二不同的是由字符串到哈希表的映射关系）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML_convid-19感染人群占比预测</title>
      <link href="blog/%E6%9D%8E%E5%AE%8F%E6%AF%85ML_convid-19%E6%84%9F%E6%9F%93%E4%BA%BA%E7%BE%A4%E5%8D%A0%E6%AF%94%E9%A2%84%E6%B5%8B/"/>
      <url>blog/%E6%9D%8E%E5%AE%8F%E6%AF%85ML_convid-19%E6%84%9F%E6%9F%93%E4%BA%BA%E7%BE%A4%E5%8D%A0%E6%AF%94%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="李宏毅ML-convid-19感染人群占比预测"><a href="#李宏毅ML-convid-19感染人群占比预测" class="headerlink" title="李宏毅ML_convid-19感染人群占比预测"></a>李宏毅ML_convid-19感染人群占比预测</h2><h3 id="目标与数据集下载"><a href="#目标与数据集下载" class="headerlink" title="目标与数据集下载"></a>目标与数据集下载</h3><p>来源：<a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php">ML 2021 Spring (ntu.edu.tw)</a></p><p>目标：预测第三天美国某周感染人数占比</p><p>数据集下载：<a href="https://www.kaggle.com/competitions/ml2021spring-hw1/data">ML2021Spring-hw1 | Kaggle</a></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader, random_split</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机种子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same_seed</span>(<span class="params">seed</span>):</span> </span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        torch.cuda.manual_seed_all(seed)</span><br><span class="line">same_seed(config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数+device，方便调节</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&#x27;valid_ratio&#x27;</span> : <span class="number">0.2</span>,</span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>:<span class="number">5121014</span>,</span><br><span class="line">    <span class="string">&#x27;select_all&#x27;</span>:<span class="literal">True</span>,</span><br><span class="line">    <span class="string">&#x27;batch_size&#x27;</span>:<span class="number">256</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>:<span class="number">1e-3</span>,</span><br><span class="line">    <span class="string">&#x27;n_epochs&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;save_path&#x27;</span>:<span class="string">&#x27;./models/model.ckpt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;early_stop&#x27;</span>:<span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据模块</span></span><br><span class="line"><span class="comment"># 划分训练集与验证集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_valid_set</span>(<span class="params">data_set, valid_ratio, seed</span>):</span></span><br><span class="line">    valid_set_size = <span class="built_in">int</span>(valid_ratio * <span class="built_in">len</span>(data_set)) </span><br><span class="line">    train_set_size = <span class="built_in">len</span>(data_set) - valid_set_size</span><br><span class="line">    train_set, valid_set = random_split(data_set, [train_set_size, valid_set_size],  generator=torch.Generator().manual_seed(seed))</span><br><span class="line">    <span class="keyword">return</span> np.array(train_set), np.array(valid_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据集    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">convid19Dataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.y = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = torch.FloatTensor(y)</span><br><span class="line">        self.x = torch.FloatTensor(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx],self.y[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.x)</span><br><span class="line"><span class="comment"># 选择特征值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_feather</span>(<span class="params">train_data,valid_data,test_data,select_all = <span class="literal">True</span></span>):</span></span><br><span class="line">    y_train,y_valid = train_data[:,-<span class="number">1</span>],valid_data[:,-<span class="number">1</span>]</span><br><span class="line">    raw_x_train,raw_x_valid,raw_x_test = train_data[:,<span class="number">1</span>:-<span class="number">1</span>],valid_data[:,<span class="number">1</span>:-<span class="number">1</span>],test_data[:,<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> select_all:</span><br><span class="line">        feat_idx = <span class="built_in">list</span>(<span class="built_in">range</span>(raw_x_train.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        feat_idx = [] <span class="comment">#待选择</span></span><br><span class="line">    <span class="keyword">return</span> raw_x_train[:,feat_idx],raw_x_valid[:,feat_idx], raw_x_test[:,feat_idx], y_train, y_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取数据</span></span><br><span class="line">train_data,test_data = pd.read_csv(<span class="string">&#x27;./covid.train.csv&#x27;</span>).values,pd.read_csv(<span class="string">&#x27;./covid.test.csv&#x27;</span>).values</span><br><span class="line">train_data,valid_data = train_valid_set(train_data,config[<span class="string">&#x27;valid_ratio&#x27;</span>],config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line">print(<span class="string">f&#x27;&#x27;&#x27;train_data_size:<span class="subst">&#123;train_data.shape&#125;</span></span></span><br><span class="line"><span class="string">valid_data_size:<span class="subst">&#123;valid_data.shape&#125;</span></span></span><br><span class="line"><span class="string">test_data_size:<span class="subst">&#123;test_data.shape&#125;</span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得数据集</span></span><br><span class="line">x_train,x_valid,x_test,y_train,y_valid = select_feather(train_data,valid_data,test_data,config[<span class="string">&#x27;select_all&#x27;</span>])</span><br><span class="line">print(<span class="string">f&quot;number of feathers:<span class="subst">&#123;x_train.shape&#125;</span>&quot;</span>)</span><br><span class="line">train_dataset,valid_dataset,test_dataset = convid19Dataset(x_train,y_train),\</span><br><span class="line">                                        convid19Dataset(x_valid,y_valid),\</span><br><span class="line">                                        convid19Dataset(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataLoader</span></span><br><span class="line">train_dataloader = DataLoader(train_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">True</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line">valid_dataloader = DataLoader(valid_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">True</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">False</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络结构模块</span></span><br><span class="line"><span class="comment"># 定义网络结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,input_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(My_model,self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.layers = nn.Sequential(</span><br><span class="line">            nn.Linear(input_dim,<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">32</span>,<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">16</span>,<span class="number">8</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">8</span>,<span class="number">1</span>),</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.layers(x)</span><br><span class="line">        x = x.squeeze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 训练模块</span></span><br><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainer</span>(<span class="params">train_loader,valid_loader,model,config,device</span>):</span></span><br><span class="line">    criterion = nn.MSELoss(reduction = <span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(),lr = config[<span class="string">&#x27;learning_rate&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    writer = SummaryWriter()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">&#x27;./models&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./models&#x27;</span>)</span><br><span class="line">    n_epochs,best_loss,step,early_stop_count = config[<span class="string">&#x27;n_epochs&#x27;</span>],math.inf,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">        model.train()</span><br><span class="line">        loss_record = []</span><br><span class="line">        train_pbar = tqdm(train_loader,leave = <span class="literal">True</span>,position = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> train_pbar:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            x,y = x.to(device),y.to(device)</span><br><span class="line">            pred = model(x)</span><br><span class="line">            loss = criterion(pred,y)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">            loss_record.append(loss.detach().item())</span><br><span class="line">            </span><br><span class="line">            train_pbar.set_description(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]&#x27;</span>)</span><br><span class="line">            train_pbar.set_postfix(&#123;<span class="string">&#x27;loss&#x27;</span>:loss.detach().item()&#125;)</span><br><span class="line">        </span><br><span class="line">        mean_train_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/train&#x27;</span>,mean_train_loss,step)</span><br><span class="line"></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        loss_record = []</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> valid_loader:</span><br><span class="line">            x,y = x.to(device),y.to(device)</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                pred = model(x)</span><br><span class="line">                loss = criterion(pred,y)</span><br><span class="line">            loss_record.append(loss.item())</span><br><span class="line">        mean_valid_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        print(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]: Train loss: <span class="subst">&#123;mean_train_loss:<span class="number">.4</span>f&#125;</span>, Valid loss: <span class="subst">&#123;mean_valid_loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/valid&#x27;</span>,mean_valid_loss,step)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> mean_valid_loss &lt;best_loss:</span><br><span class="line">            best_loss = mean_valid_loss</span><br><span class="line">            torch.save(model.state_dict(),config[<span class="string">&#x27;save_path&#x27;</span>])</span><br><span class="line">            print(<span class="string">&#x27;Saving model with loss &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_loss))</span><br><span class="line">            early_stop_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            early_stop_count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> early_stop_count &gt;= config[<span class="string">&#x27;early_stop&#x27;</span>]:</span><br><span class="line">            print(<span class="string">&#x27;\nModel is not improving, so we halt the training session.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">model = My_model(input_dim = x_train.shape[<span class="number">1</span>]).to(device)</span><br><span class="line">trainer(train_dataloader,valid_dataloader,model,config,device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的loss变化</span></span><br><span class="line">%reload_ext tensorboard</span><br><span class="line">%tensorboard --logdir=./runs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测模块</span></span><br><span class="line"><span class="comment"># 保存预测值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_pred</span>(<span class="params">preds,file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        writer = csv.writer(fp)</span><br><span class="line">        writer.writerow([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;tested_positive&#x27;</span>])</span><br><span class="line">        <span class="keyword">for</span> i,p <span class="keyword">in</span> <span class="built_in">enumerate</span>(preds):</span><br><span class="line">            writer.writerow([i,p])</span><br><span class="line"><span class="comment"># 预测函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">test_loader,model,device</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    preds=[]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">        x = x.to(device)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            pred = model(x)</span><br><span class="line">            preds.append(pred.detach().cpu())</span><br><span class="line">    preds = torch.cat(preds,dim = <span class="number">0</span>).numpy()</span><br><span class="line">    <span class="keyword">return</span> preds </span><br><span class="line"><span class="comment"># 进行预测            </span></span><br><span class="line">model = My_model(input_dim = x_train.shape[<span class="number">1</span>]).to(device)</span><br><span class="line">model.load_state_dict(torch.load(config[<span class="string">&#x27;save_path&#x27;</span>]))</span><br><span class="line">preds = predict(test_dataloader,model,device)</span><br><span class="line">save_pred(preds,<span class="string">&#x27;pred.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> pytorch </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 机器学习基本概念</title>
      <link href="blog/01%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>blog/01%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h2><blockquote><p>机器学习就是让机器具备找一个函数的能力</p></blockquote><h3 id="机器学习的任务"><a href="#机器学习的任务" class="headerlink" title="机器学习的任务"></a>机器学习的任务</h3><ol><li><p>Regression:函数输出是一个数值，例如：</p><ul><li>预测某一时间PM2.5的数值</li></ul></li><li><p>Classification:做选择题，从设置好的答案中选择正确的当作输出，例如：</p><ul><li>判断垃圾邮件，输出为 是 与 不是 中的一个</li><li>阿尔法狗，输出为棋盘上剩余位置中的一个</li></ul></li><li><p>Structured Learning：输出有结构性的结果，例如：</p><ul><li>创造一篇文章</li><li>画一个图</li></ul></li></ol><h3 id="训练（如何找到一个函数）"><a href="#训练（如何找到一个函数）" class="headerlink" title="训练（如何找到一个函数）"></a>训练（如何找到一个函数）</h3><ol><li><p>Function with Unkown Parameters(写出一个带有未知参数的函数)</p><p>依靠Demain knowledge(即对问题的理解)，先简单猜测一下输入输出之间的关系，写出带有未知参数的函数(或许可以用下最小二乘法)</p></li><li><p>Define Loss from Training Data(判断原有模型的好坏)</p><p>定义Loss为一个可以评判模型好坏的标准，可以通过训练资料得到Loss，例如将Loss设为每次推测结果与实际结果之间差的绝对值的平均数</p></li><li><p>Optimization（最优化）</p><p>找到最好的位置参数（即找到可使得Loss最小的未知参数）；可采用梯度下降法</p></li></ol><h3 id="更有弹性的模型"><a href="#更有弹性的模型" class="headerlink" title="更有弹性的模型"></a>更有弹性的模型</h3><h4 id="使用sigmoid建立一个更有弹性的模型"><a href="#使用sigmoid建立一个更有弹性的模型" class="headerlink" title="使用sigmoid建立一个更有弹性的模型"></a>使用sigmoid建立一个更有弹性的模型</h4><p>可以用Piecewise Linear 的Curves逼近任何连续曲线（即用折线逼近曲线），而Piecewise Linear的Curves是由多个function（相当于折线图中每一个直线）相加得到的，function又可以利用sigmoid逼近得到（当然也可以用其他函数逼近）</p><p>sigmoid:</p><script type="math/tex; mode=display">y = c/(1+e^{-(b+wx_1)})</script><p>即</p><script type="math/tex; mode=display">y = c*sigmoid(b+wx_1)</script><p>可根据不同的w，b, c调整sigmoid。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118353.png" alt="QQ截图20230420164915"></p><p>拟合得到的曲线函数：</p><script type="math/tex; mode=display">y = b + \sum_ic_i *sigmoid(b_i+w_ix_i)</script><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118354.png" alt="QQ截图"></p><p>如上图所示，可将逼近曲线的过程转换为线性代数的表达，其中b（标量），$c^T$, b(向量)， W均为未知参数，可将这些未知参数拼成一个向量$\theta$;由此我们已经得到了一个函数，接下来需要进行训练的第2、3步:</p><p>Loss是一个关于$\theta$的函数，即L($\theta$)（至于如何定义L，可根据题目需要进行），而对其进行优化的过程与前面线性模型的方法基本相同（梯度下降法）。</p><h4 id="epoch与update的概念"><a href="#epoch与update的概念" class="headerlink" title="epoch与update的概念"></a>epoch与update的概念</h4><p>事实上，在做Optimization时，并不是一次将全部的资料都拿来训练，而是将其随机分为几份batch（至于到底几个batch自己定义），每次用一份batch进行训练，对$\theta$进行更新，而将全部资料都训练一次，称为一个epoch，每次用一个batch进行训练，称为一个update；</p><h4 id="ReLU-与sigmoid均为Activation-function的一种"><a href="#ReLU-与sigmoid均为Activation-function的一种" class="headerlink" title="ReLU(与sigmoid均为Activation function的一种)"></a>ReLU(与sigmoid均为Activation function的一种)</h4><p>除了sigmoid外，我们还可以利用其他函数来达到逼近的目的，例如ReLU</p><script type="math/tex; mode=display">c*max(0,b+wx_i)</script><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118355.png" alt="QQ截图20230422122016">在机器学习中，我们称sigmoid、ReLU这类函数为Activation function。</p><h4 id="继续改进模型，得到Deep-Learning"><a href="#继续改进模型，得到Deep-Learning" class="headerlink" title="继续改进模型，得到Deep Learning"></a>继续改进模型，得到Deep Learning</h4><p>我们可以多做几次从x到a的过程<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118356.png" alt="QQ截图20230422121803"></p><p>每一个sigmoid或者ReLU都是一个Neuron(神经元),这也就是一个神经网络模型。后来，又称每一个Neuron为一个layer，如何一个模型有很多个layer，我们就将其称为Deeping Learning。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 模型训练过程中可能出现的问题</title>
      <link href="blog/02%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>blog/02%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模型训练过程中可能出现的问题"><a href="#模型训练过程中可能出现的问题" class="headerlink" title="模型训练过程中可能出现的问题"></a>模型训练过程中可能出现的问题</h2><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118253.png" alt="QQ截图20230422123240"></p><h3 id="Loss-on-training-data-较大"><a href="#Loss-on-training-data-较大" class="headerlink" title="Loss on training data 较大"></a>Loss on training data 较大</h3><h4 id="model-bias"><a href="#model-bias" class="headerlink" title="model bias"></a>model bias</h4><ol><li><strong>原因</strong>：模型太过于简单，弹性不够。</li><li><strong>解决方法</strong>：重新设计模型，让模型更有弹性。</li></ol><h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><p><strong>原因</strong>：优化方法不够好。</p><h4 id="如何区分model-bias与optimization？"><a href="#如何区分model-bias与optimization？" class="headerlink" title="如何区分model bias与optimization？"></a>如何区分model bias与optimization？</h4><p>先训练些比较简单的model，再训练比较复杂的model，如果较复杂的model结果反而不如较简单的，就说明是optimization出了问题。</p><h3 id="Loss-on-training-data-较小"><a href="#Loss-on-training-data-较小" class="headerlink" title="Loss on training data 较小"></a>Loss on training data 较小</h3><h4 id="overfitting"><a href="#overfitting" class="headerlink" title="overfitting"></a>overfitting</h4><p>模型训练结果越来越好，但预测结果在达到一定程度后越来越差。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118254.png" alt="QQ截图20230422125629"></p><ol><li><strong>原因</strong>：模型太复杂，太灵活了。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118255.png" alt="QQ截图20230422125356"></li><li><strong>解决方法</strong>：<ul><li>使用更多训练资料（不建议）；</li><li>Data augmentation（对已有资料进行处理，得到更多资料，例如将照片镜像）；</li><li>给模型加上一些限制。</li></ul></li></ol><h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118256.png" alt="QQ截图20230422130221">    训练资料与测试资料差异较大</p><h3 id="如何选择模型"><a href="#如何选择模型" class="headerlink" title="如何选择模型"></a>如何选择模型</h3><p>​    可以将自己的资料分成多份，分别作为训练资料和预测资料，以选择最好的模型。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 训练神经网络的一些tips</title>
      <link href="blog/03%20%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9Btips/"/>
      <url>blog/03%20%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9Btips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="训练神经网络的一些tips"><a href="#训练神经网络的一些tips" class="headerlink" title="训练神经网络的一些tips"></a>训练神经网络的一些tips</h1><h2 id="local-minima-and-saddle-point"><a href="#local-minima-and-saddle-point" class="headerlink" title="local minima and saddle point"></a>local minima and saddle point</h2><p>前面已经说过了，当模型训练结的Loss过大时，可能是模型本身的原因（model bias）和optimization过程没有做好，那么如何改良optimization过程呢？</p><p>首先我们要知道optimization出现问题很可能是遇到了critical point。</p><p><strong>critical point</strong>( 临界点，gradient 为 0)</p><ul><li><p>local minima （梯度为0且是局部最低点）</p></li><li><p>saddle point  （梯度为0但并不是局部最低点）</p></li></ul><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113225.JPG" alt="捕获"></p><p><strong>如何去辨别是哪一种critical point？</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113226.PNG" alt="捕获"></p><p>当位于临界点时，g（梯度）为0，可以认为</p><script type="math/tex; mode=display">L(\theta) = L(\theta^. )+1/2(\theta-\theta^.)^TH(\theta-\theta^.)</script><p>之后可以根据H判断是哪种临界点；</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113227.PNG" alt="捕"></p><p>当临界点为saddle point时的做法</p><p>我们可以根据H去更新$\theta$</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113228.PNG" alt="001"></p><p>Local minima 在更高级的维度中或许也是 一个saddle point。</p><h2 id="Batch-and-Momentum"><a href="#Batch-and-Momentum" class="headerlink" title="Batch and Momentum"></a>Batch and Momentum</h2><h3 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h3><p>将资料分成多个Batch的过程，常见的做法是在每一个Epoch之前分一次Batch，每一次的Batch都不一样。</p><h3 id="为什么要采用Batch"><a href="#为什么要采用Batch" class="headerlink" title="为什么要采用Batch"></a>为什么要采用Batch</h3><p>时间？事实上，因为有平行运算的原因，large Batch（例如只分出1个Batch）在时间上往往要比small Batch更占优势（超大数据集除外）</p><p>答案是small Batch的Optimization做的更好，small Batch的update过程是更noisy的，但恰恰是更noisy更有利于optimization的。为什么呢？因为如果是large batch，在update过程中遇到一个local minima或者saddle point就停下来了，而对于small batch，由于每次训练采用的数据集不同，因此function也不同，当一个function遇到local minima或者saddle point停下来了，却不会影响另一个function。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625355.png" alt="batch"></p><p>除此之外，small Batch也更有利于预测（或测试），其原因尚有争论，有一个观点是small Batch更有利于遇到flat minima,而large Batch更倾向于进入sharp minima。（flat minima指周围梯度绝对值较小的点，而sharp minima则与之相反，由于测试的数据集与训练的数据集可能存在差别，flat minima显然更有包容性，而small Batch在遇到sharp minima时，更有可能跳出去，因此测试结果更好）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625196.png" alt="good-bad-local"></p><p><strong>small Batch 与 large Batch对比</strong>：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625295.png" alt="s-b对比"></p><h3 id="momentum"><a href="#momentum" class="headerlink" title="momentum"></a>momentum</h3><p>每次$\theta$的移动并不是只考虑gradient ，而是考虑过去所有gradient的总和。</p><p>即每次移动的方向为梯度反方向+原来移动方向</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625285.png" alt="mumentum"></p><p> 这种方法的好处是可以有效避免local minima和saddle point（可以类比一下惯性)。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625228.png" alt="mu"></p><h2 id="自动调整学习速率"><a href="#自动调整学习速率" class="headerlink" title="自动调整学习速率"></a>自动调整学习速率</h2><h3 id="不变的learning-rate存在的问题："><a href="#不变的learning-rate存在的问题：" class="headerlink" title="不变的learning rate存在的问题："></a>不变的learning rate存在的问题：</h3><ol><li><p>如果learning rate比较大，可能无论如何都无法到达最低点，而是在最低点旁左右横条</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626991.png" alt="rate large"></p></li><li><p>如果learning rate比较小，问题1得到一定程度的解决，但是当grandient比较大时，移动的还比较快，当grandient比较小时，就会出现移动的很慢的情况。</p></li></ol><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626202.png" alt="rate"></p><h3 id="Root-Mean-Square与RMSProp"><a href="#Root-Mean-Square与RMSProp" class="headerlink" title="Root Mean Square与RMSProp"></a>Root Mean Square与RMSProp</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626112.png" alt="02"></p><p>引入一个新的参数$\sigma_i^t$, 这样可以实现learning rate自动调整的目的，但这样存在一个问题，那就是最开始移动的g与最近移动的g对于$\sigma$的大小的影响是相同的，这样learning rate对于g变化的反应是比较缓慢的，那么做到让learning rate更快地对g变化做出反应呢？我们可以使用RMSProp</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626066.png" alt="sig"></p><h3 id="learning-Rate-Scheduling"><a href="#learning-Rate-Scheduling" class="headerlink" title="learning Rate Scheduling"></a>learning Rate Scheduling</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626133.png" alt="yz"></p><p>在进入grandient较小的区域后，在纵轴方向累计了很多很小的$\sigma$,当累计到一定程度后，可能就会出现如图所示的情况。为了解决这一问题，可以使用learning Rate Scheduling</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626124.png" alt="？？"></p><p>即让$\eta$也随移动而变化，如何变化呢？有两种方案：</p><ul><li>learning rate decay：即从大到小，</li><li>warm up：先从小增大到一定程度，再减小，原因：刚开始的$\sigma$是不准确的，因此先缓慢移动，等$\sigma$达到一定的准确程度，再继续快速移动.</li></ul><h3 id="自动更新学习速率-Momentum"><a href="#自动更新学习速率-Momentum" class="headerlink" title="自动更新学习速率+Momentum"></a>自动更新学习速率+Momentum</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626524.png" alt="s+m"></p><p>在$\sigma$的更新过程中，是与方向无关的（取了平方），因此与momentum不会抵消。</p><h2 id="批次标准化（batch-normalization）"><a href="#批次标准化（batch-normalization）" class="headerlink" title="批次标准化（batch normalization）"></a>批次标准化（batch normalization）</h2><p>当一个模型的多个输入差异比较大时（比如$x_1$在0-1，$x_2$在100-200之间，那么$x_1$如果发生改变对最后Loss的影响一定是远大于$x_2$的，因此我们希望<strong>让不同维度的输入有一致的范围，让优化更简单</strong></p><h3 id="feature-Normalization（特征归一化）"><a href="#feature-Normalization（特征归一化）" class="headerlink" title="feature Normalization（特征归一化）"></a>feature Normalization（特征归一化）</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627635.png" alt="feature normalization"></p><p>我们将每个维度的输入都转化为同一范围的量的过程称为标准化，如上图所示即为标准化的过程，但是图中的标准化mean和$\sigma_i$的来源都是所有资料，但是我们知道，我们正常是要分成很多个batch，那么该怎么办呢？</p><h3 id="batch-Normalization"><a href="#batch-Normalization" class="headerlink" title="batch Normalization"></a>batch Normalization</h3><p>每个batch并不是同步进行的，为了完成feature Normalization的过程，我们可以将求所有资料的mean和$\sigma$变为这个batch的。</p><h3 id="多次标准化"><a href="#多次标准化" class="headerlink" title="多次标准化"></a>多次标准化</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627581.png" alt="deep-num"></p><p>在深度学习中，是有多层layer的，上一个layer的输出也是下一个layer的输入，第一层输入做了feature Normalization，但后面的输出却没有做，这显然是不合理的，因此我们可以对每层的输出都做一个feature Normalization。至于这个feature Normalization放在sigmoid这类激化函数前后都是可以的（不过sigmoid一般建议放在前面，因为sigmoid函数在0附近grandient较大)。</p><p>在某些情况下，我们希望最后的输出并不是以0为mean的，因此在输出精确到一定程度后可以对其进行变换：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627440.png" alt="afbt"></p><h3 id="testing时的batch-Normalization"><a href="#testing时的batch-Normalization" class="headerlink" title="testing时的batch Normalization"></a>testing时的batch Normalization</h3><p>在实际使用的测试过程中，可能一次输入并没有一个batch，这时batch Normalization可能会出现问题，pytorch给了解决方案，即在训练时每一个batch，都会将其mean和$\sigma$拿来做一个平均值，之后用来作为测试时的mean和标准差</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627436.png" alt="meanmean"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 卷积神经网络(CNN)</title>
      <link href="blog/05%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/"/>
      <url>blog/05%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h2><p>输入：图片（默认大小是一致的）</p><p>输出：独热码（每个独热码代表其中一种分类）</p><h3 id="卷积神经网络的第一种表达"><a href="#卷积神经网络的第一种表达" class="headerlink" title="卷积神经网络的第一种表达"></a>卷积神经网络的第一种表达</h3><h4 id="如何把一张影响变成输入？"><a href="#如何把一张影响变成输入？" class="headerlink" title="如何把一张影响变成输入？"></a>如何把一张影响变成输入？</h4><p>每张图片实际上是一个三维的tensor，三个维度：长、宽、层数（例如：RGB三个channels），将其拉直成一个向量，即可实现影像输入（如下图所示）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118668.PNG" alt="将图片作为输入"></p><p>在拉直得到的向量中，每个元素的数值即代表了某一个位置某一种颜色的强度。</p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>如果安装原来的Fully Connected Network对输入的向量进行处理，太过复杂，会增大overfitting的风险，那么该如此简化呢？</p><h5 id="每个Neuron只负责图片的一小部分"><a href="#每个Neuron只负责图片的一小部分" class="headerlink" title="每个Neuron只负责图片的一小部分"></a>每个Neuron只负责图片的一小部分</h5><p>每个Neuron的图片的部分称为一个receptive field，不同Neuron的receptive field可以重叠，多个Neuron可以负责一个receptive field（因为一些图片的特征可能不只有一个）。</p><p><strong>最经典的receptive field安排方式</strong></p><p>每个Neuron负责所有channels ，长和宽一般3x3，一个receptive field移动stride（自定义）即可得到另一个receptive field（stride自定义），移动时超出范围，可补0。</p><h5 id="共享参数"><a href="#共享参数" class="headerlink" title="共享参数"></a>共享参数</h5><p>一个特征可能同时出现一个图片的不同位置；因为我们可以让负责这一特征的Neuron共享参数</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118669.PNG" alt="共享参数"></p><p>每个receive field都有一组neuron在负责，不同receive field的对应neuron共享参数，我们将每一个neuron的参数称为一个fitler（卷积核）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118670.PNG" alt="如何共享参数"></p><p>在经过2.1和2.2后的网络层就是<strong>卷积层</strong>，使用卷积层的神经网络即为<strong>卷积神经网络</strong>。</p><h3 id="卷积神经网络的另一种表达"><a href="#卷积神经网络的另一种表达" class="headerlink" title="卷积神经网络的另一种表达"></a>卷积神经网络的另一种表达</h3><p><strong>feature map</strong></p><p>用n个filter对图片的特征进行抓取，每个filter负责一个特征。在一个filter的抓取全部完成后可以得到一个一层的tensor（如下图）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118671.PNG" alt="filter1"></p><p>而n个filter全部进行一遍后既可得到一个n层的tensor，即为一个feature map。而feature map又可以看出一个拥有n个channels的图片，作为下一层的输入，而下一层的filter也要是一个n个channels的tensor（如下图）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118672.PNG" alt="多层卷积"></p><p>如果使用3*3的filter是否可以抓取原图像中更大部分才能体现的特征？答案是可以的，因为使用了多层卷积之后得到的feature map中可以一个元素就能体现出原来很大部分的特征。</p><h3 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h3><p>将一个比较大图片做一个subsampling（如把偶数的行、奇数列去除），图片变为原来的1/4，但不会影响图片特征的提取</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118673.PNG" alt="pool"></p><p>如何做pooling？</p><p>将每个filter经过提取后得到的tensor中元素分成几个小组，从组中选出有代表性的元素留下来，其他元素去除（如下图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118674.PNG" alt="pooling"></p><p>max pooling：选择最大的元素作为代表。</p><p>pooling会对精确度造成损失，因此也<strong>可以不用</strong>。</p><h3 id="CNN图片识别流程"><a href="#CNN图片识别流程" class="headerlink" title="CNN图片识别流程"></a>CNN图片识别流程</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118675.PNG" alt="THE WHOLE CNN"></p><p>经过卷积和池化（pooling，可以不用）后的输出经过flatten可以得到一个向量，再经过全连接层和softmax即可得到最后的输出</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 Classification</title>
      <link href="blog/04%20Classification%EF%BC%88%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>blog/04%20Classification%EF%BC%88%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><h3 id="如何做分类"><a href="#如何做分类" class="headerlink" title="如何做分类"></a>如何做分类</h3><ul><li><p>当作预测数值</p><p>每个分类之间是无关的，但预测的数值之间却存在关系的远近，例如将预测结果0当作分类A，预测结果1当作分类B，预测结果100当作分类C，显然预测数值1和2之间关系要比1和100更接近，但分类A,B,C之间是不存在这种关系的，因此这种做法并不合适。</p></li><li><p>把每个分类结果当作独热码</p></li></ul><h3 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116882.PNG" alt="softmax"></p><p>Classification需要对结果进行一次softmax，softmax步骤如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116883.PNG" alt="soft-max"></p><p>这样得到的结果，全都在0-1，且和为1</p><h3 id="Loss-of-Classification"><a href="#Loss-of-Classification" class="headerlink" title="Loss of Classification"></a>Loss of Classification</h3><p>在进行分类时对Loss的定义</p><ol><li><p>Mean Square Error(MSE)</p><script type="math/tex; mode=display">e = \sum_i(\widehat{y}_i-\dot{y_i})^2</script></li><li><p>Cross-entropy </p><script type="math/tex; mode=display">e = -\sum_i\widehat{y}_iln\dot{y_i}</script></li></ol><p><strong>分类时cross-entroy更适用。</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116884.PNG" alt="cross"></p><p>如上图所示，MSE的结果在Loss比较大时grandient比较小，更难update到loss小的地方，而cross-entropy的结果更有利于优化（optimization）。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 self-attention</title>
      <link href="blog/06%20self-attention/"/>
      <url>blog/06%20self-attention/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h2><p>输入：一个向量的集合（例如：音频、语句、图、分子等）</p><p>输出： </p><ul><li><p>case1：输入输出长度一样（例如文字处理过程中的词性标注）</p></li><li><p>case2：只输出一个label</p></li><li><p>case3： 不知道需要输出多少个label</p></li></ul><h3 id="为什么要使用self-attention"><a href="#为什么要使用self-attention" class="headerlink" title="为什么要使用self attention"></a>为什么要使用self attention</h3><p>对于case1，即输入输出长度一样的情况，又可以称为Sequence Labeling</p><p>如何解决这种问题？如果按照之前的，只使用全连接层（即每个向量经过各种Neuron得到最终的输出）得到的结果有着巨大的缺陷，因为这样在每个向量计算过程实际只考虑了一个向量，但是实际上，每个向量的输出与输入集合中其他向量都是存在关系的（例如，“I saw a saw”，这个句子中两个“saw”有着不同的词性，但只用全连接层输出可能相同），这种关系是我们需要考虑的。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117803.PNG" alt="isawasaw"></p><p>如何才能考虑到这种关系的存在呢？在这里引入了self attention。self attention的输入和输出个数是相同的，每个输入向量都会对应一个输出向量（该输出向量是考虑了该向量与输入集合内其他向量之间关系的），之后将self attention得到的输出向量作为后续网络层的输入，就可以达到实现考虑输入集合内关系的效果。</p><h3 id="如何实现self-attention"><a href="#如何实现self-attention" class="headerlink" title="如何实现self attention"></a>如何实现self attention</h3><h4 id="计算两个向量相关性的方法"><a href="#计算两个向量相关性的方法" class="headerlink" title="计算两个向量相关性的方法"></a>计算两个向量相关性的方法</h4><p>dot product &amp; additive</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101644150.png" alt="计算attention"></p><h4 id="计算self-attention输出的过程"><a href="#计算self-attention输出的过程" class="headerlink" title="计算self attention输出的过程"></a>计算self attention输出的过程</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117804.PNG" alt="计算selfattention输出"></p><p>如上图所示，解释了如果得到其中一个输出（$b^1$）的过程,而得到其他输出的过程与之类似。</p><p>而整个过程的矩阵表达如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117805.PNG" alt="selfattention矩阵"></p><p>在这个过程中，只有三个变换所需矩阵是要经过学习得到的（$W^q,W^k,W^v$）。</p><h4 id="multi-head-self-attention"><a href="#multi-head-self-attention" class="headerlink" title="multi-head self-attention"></a>multi-head self-attention</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117806.PNG" alt="mutiself"></p><p>在有些情况下，输入集合内向量的关系并不是只有一种类型，因此我们可以使用multi-head self-attention，这样可以考虑多种关系。实现过程是在原有self-attention的基础上增加$W^q,W^k,W^v$的数量。</p><h4 id="positional-encoding"><a href="#positional-encoding" class="headerlink" title="positional encoding"></a>positional encoding</h4><p>在某些情况下，输入集合内向量的位置也是很重要的（例如句子中第一个单词往往是主语），</p><p>因此在这种情况下，我们可以使用一组向量（$e^1,e^2,…，e^i)$存储位置，每个位置对应的向量是不同的，将其作为输入，这样在学习过程中就会考虑位置的因素。（如下图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117807.PNG" alt="position"></p><h3 id="self-attention的应用"><a href="#self-attention的应用" class="headerlink" title="self attention的应用"></a>self attention的应用</h3><h4 id="语言识别"><a href="#语言识别" class="headerlink" title="语言识别"></a>语言识别</h4><p><strong>truncated self-attention</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117808.PNG" alt=""></p><p>由于音频的数据量是很庞大的，如果全都拿来做self attention，运算量较大，因此我们可以每次只考虑附近几个向量之间的关系，即truncated self-attention，如上图所示。</p><h4 id="影像处理"><a href="#影像处理" class="headerlink" title="影像处理"></a>影像处理</h4><p><strong>self-attention VS CNN</strong></p><p>CNN是self attention的一个特例，之前说CNN中是把一个图片拼成一个向量作为输入，实际上，也可以将其作为一个向量的集合作为输入，使用self attention解决。</p><h4 id="图处理"><a href="#图处理" class="headerlink" title="图处理"></a>图处理</h4><p>在图中节点之间是否有连线实际上说明了节点之间的关系，所以我们可以只考虑之间有连线的节点之间的关系。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117809.PNG" alt="GNN"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 Transformer</title>
      <link href="blog/07%20Transformer/"/>
      <url>blog/07%20Transformer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><blockquote><p>这是一个sequence-to-sequence（seq2seq）的模型</p></blockquote><p>可以解决不知道输出长度的问题，例如</p><ul><li><p>语音辨识</p></li><li><p>multi-label classification</p></li><li><p>object detection</p></li><li><p>……</p></li></ul><h3 id="Transformer内部架构"><a href="#Transformer内部架构" class="headerlink" title="Transformer内部架构"></a>Transformer内部架构</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117984.PNG" alt="transformer"></p><p>Transformer主要由encoder和decoder两部分组成，encoder可以实现输出一排长度与输入相同的向量，decoder可以实现输出一排由模型自己决定的长度的向量。</p><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><blockquote><p>给一排向量，输出同样长度的一排向量</p></blockquote><p>encoder包含了很多个block，</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117985.PNG" alt="encoder"></p><p>每个block包括的过程如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117986.PNG" alt="encoderblock"></p><p>即输入的一排向量（b），先经过一次self-attention得到a,之后与原输入向量（b）相加（residual network）得到a+b，再经过一次layer normalization得到c，得到的结果c作为下一层的输入，在下一层将经过一次全连接层得到d，d会与c相加（residual network）得到c+d，经过一次layer normalization后得到这个block的输出。</p><h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><h5 id="Autoregressive（AT，常见的一种decoder）"><a href="#Autoregressive（AT，常见的一种decoder）" class="headerlink" title="Autoregressive（AT，常见的一种decoder）"></a>Autoregressive（AT，常见的一种decoder）</h5><p>AT 这种decoder的输出是一个一个产生的，在最开始时，decoder会有一个开始符（begin）和encoder的输出一起作为输入，得到第一个输出的向量（得到输出向量的过程是一个概率分布，例如经过decoder后，得到每个字对应分数，“机”字得分占总得分的0.8，“你”占0.1，“end”（结束符，输出此向量后，结束输出）占0.1，那么“机”字就有0.8的概率作为输出），之后此向量代替开始符和encoder的输出一起作为下一次的输入，依次类推，直至输出结束符（end）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117987.PNG" alt="at"></p><h5 id="decoder的内部结构"><a href="#decoder的内部结构" class="headerlink" title="decoder的内部结构"></a>decoder的内部结构</h5><blockquote><p>decoder的结构与encoder相似</p></blockquote><p><strong>masked Multi-Head Attention</strong></p><p>decoder的Multi-Head Attention需要masked，那么什么是masked呢？</p><p>就是在做注意力机制时，不考虑右边的向量，即将右边的masked，如图所示</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117988.PNG" alt="masked"></p><p>在产生$b^1$时只能考虑$a^1$而不能考虑$a^1$之后的。</p><p><strong>cross attention</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117989.PNG" alt=" "></p><p>在decoder经过masked Multi-Head Attention后和encoder的输出一起做了下一个模块的输入，这个模块即为cross attention，其具体过程如下图所示：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117990.PNG" alt="crossattention"></p><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><p>同时产生多个输出，decoder的输入一直都是begin和encoder的输出（即不会像AT那样将decoder的输出作为输入），实现平行化，速度更快，但是效果不好。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117991.PNG" alt="nat"></p><p>NAT如何解决在合适时候停止的问题？</p><ol><li>另外训练一个模型，输入为encoder的输出，输出为一个数字（代表decoder应该输出的长度）</li><li>给一个比较大数量的begin，这样就会输出一个很长的向量集合，再决定在哪里断开。</li></ol><h5 id="训练过程（train）"><a href="#训练过程（train）" class="headerlink" title="训练过程（train）"></a>训练过程（train）</h5><p><strong>teacher forcing</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117992.PNG" alt="traintransformer"></p><p>在decoder的训练过程中，会直接把正确的答案作为decoder的输入，这个过程称为teacher forcing，这个过程可能会导致mismatch。</p><h3 id="训练transformer的一些tips"><a href="#训练transformer的一些tips" class="headerlink" title="训练transformer的一些tips"></a>训练transformer的一些tips</h3><p><strong>chat-bot</strong></p><p>复制一些内容，例如聊天机器人、做摘要等。可以使用pointer network。</p><p><strong>guided attention</strong></p><p>要求在学习过程中的attention有一些属性是固定的。</p><p><strong>beam search</strong></p><p>可能每次都选最好的结果最后反而效果不好，可以在一些时候舍弃一些东西，加一些随机性。，例如下图中红色的路和绿色的路：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117993.PNG" alt="beem search"></p><p><strong>Scheduled Sampling</strong></p><p>如何解决train中使用了正确答案导致可能出现mismatch的问题？</p><p>可以给一些错误的答案。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="blog/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 </a></p><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length-<span class="number">1</span>:</span><br><span class="line">            temp = ListNode()</span><br><span class="line">            temp = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = temp</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        head = q</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        q = ListNode()</span><br><span class="line">        q = head</span><br><span class="line">        temp = ListNode()</span><br><span class="line">        temp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span>:</span><br><span class="line">            p = q</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = temp</span><br><span class="line">            temp = p</span><br><span class="line">        head = p</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">p,q</span>):</span></span><br><span class="line">            <span class="keyword">if</span> q == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            temp = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            <span class="keyword">return</span> reverse(q,temp)</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>,head)</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>翻转链表可以考虑使用双指针法，但是双指针之间亦有差别，例如：</p><ul><li>解一中两个指针分别放在原链表的首尾端，依次将首端的链点用头插法插在尾部指针指向链点的后面，这样，当原链表中链点全部加入尾端时，就成功实现了链表的反转，新链表首节点即为q.next（注意，其实原链表的尾端可以直接当作新链表的首端的，这一原来的尾端指针q就是head了，解一中也是这样写的）</li><li>解二中两个指针刚开始都在首段的，它们每往后移动一位都会将原来两个链点之间的指向反转（q指针的意义是为p指针指路，防止p指针在p.next = temp后无法找到原链表后续的链点）</li></ul></li><li><p>因为我采用了虚拟节点，因此需要格外注意原链表的第一个链点和原链表为None这两种情况;</p></li><li><p>解三的思路与解二是一样的，但是使用了递归：我们可以看出解二的过程实际上是p，temp两个指针指向链点之间指针的反转，可以用递归来处理，要注意递归时输入形参是什么（即要注意在下一次循环中p，temp对应什么），还要注意递归需要有停止的途径。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方</title>
      <link href="blog/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>blog/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><blockquote><p>给你一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>示例 1：</p><p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums_new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            nums_new.append(i*i)</span><br><span class="line">        nums_new.sort()</span><br><span class="line">        <span class="keyword">return</span> nums_new</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        nums_new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            temp = i*i</span><br><span class="line">            <span class="keyword">if</span> nums_new == []:</span><br><span class="line">                nums_new.append(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> nums_new:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= temp:</span><br><span class="line">                        nums_new.insert(nums_new.index(i),temp)</span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                    nums_new.append(temp)</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> nums_new</span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> nums[i]*nums[i] &lt; nums[j]*nums[j]:</span><br><span class="line">                result.insert(<span class="number">0</span>,nums[j]*nums[j])</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.insert(<span class="number">0</span>,nums[i]*nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解法一，先得到列表内所有元素平方之后再对其进行排序，解法二，在得到列表内每个元素的平方之后，利用直接插入排序的思路对其进行排序，最后得到已经排序的平方列表；但这两种方法时间复杂度都较高。</li><li>根据题意可知，原列表内元素平方后得到的新列表中，并不是没有顺序，只是最小值在中间（原列表有负数时），最大值在两端而已，因此可以用两个指针分别指向首段和尾端，根据$(nums[i])^{2}$和$(nums[j])^{2}$的大小判断将哪一端先放入结果中，放入结果的端点的指针需要移动。此外需要注意循环的条件，首端指针i，末端指针j，其判断条件应为i &lt;= j，否则会出现在最后有一个指针指向元素的平方未放入结果列表的情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="blog/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">142. 环形链表 II - 力扣（LeetCode）</a></p><blockquote><p> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        lis = []</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">in</span> lis:</span><br><span class="line">                <span class="keyword">return</span> p.<span class="built_in">next</span></span><br><span class="line">            lis.append(p.<span class="built_in">next</span>)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        p,q = head,head</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span> <span class="keyword">and</span> p.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                p = head</span><br><span class="line">                <span class="keyword">while</span> p != q:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一将所有遍历过的链点都存储在一个列表中，判断新遍历的列表是否在列表中，若已在列表中，就说明在这里产生了环；</li><li>解二使用了双指针法，当快指针与慢指针相遇时，设慢指针走了k，与环起点距离为m，则快指针走了2k，且从相遇点到环起点的距离$L_1$和从head到环起点的距离$L_2$均为k-m，这时我们可以设置快慢指针中一个指针指向head，两指针以同样速率移动，当两指针相遇，则相遇点恰好为环的起点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">len</span> = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 </strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 50</li><li>0 &lt;= val &lt;= 100</li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>解一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums_new = nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums_new:</span><br><span class="line">            <span class="keyword">if</span> i == val:</span><br><span class="line">                nums.remove(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>解二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>解三(示例代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def removeElement(self, nums, val):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while i &lt; len(nums):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; val:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                i &#x3D; i - 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><p>解四（双指针法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>在python中，使用了remove（），该方法会移除列表中的某个值的第一个匹配项。但是需要注意，如果需要删除的值在列表中有相邻的，只用一次for循环+remove（）无法将其全部删除，因为remove（）方法会改变列表中原有的索引。可以采取的方案：为该列表创建一个副本，for循环遍历副本，但删除原列表中元素（即解一做法，但这种情况与题意“仅使用O（1）额外空间不符”），也可以使用while循环来删除对应元素；</li><li>示例代码给出了另一种思路，即使用索引，用pop（）方法进行删除；</li><li>也可使用双指针法，两个指针一快一慢，遍历整个列表，当快指针指向的元素为需要删除的时，慢指针不动快指针后移，当快指针指向元素不是需要删除的时， nums[slow] = nums[fast]，且快慢指针均后移。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="blog/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>blog/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p><p>示例 1：</p><p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">#class ListNode(object):</span></span><br><span class="line">    <span class="comment">#def __init__(self, val=0, next=None):</span></span><br><span class="line">        <span class="comment">#self.val = val</span></span><br><span class="line">        <span class="comment">#self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val == val:</span><br><span class="line">                head = p.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">if</span> p.val == val:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            head = p</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>解二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sta = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = sta</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>python中不可变数据类型有：整型、浮点型、元组（改变变量值后，变量指向内存位置改变即为不可变类型）；</li><li>python中也是有指针的，python采用基于值的内存管理模式，每个变量都可以理解为指针（这也是为什么要用a = b[:]来创建一个不会影响原列表的列表副本），当指向不可变数据类型的变量改变值，会发生指向内存位置的改变；</li><li>解二中将后续移动的指针定义在head前面，即p.next = head，这样之后就不需要将链表首端和尾端为需要删除链点当作特殊情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组</title>
      <link href="blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一（会超出时间限制）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result_final = []</span><br><span class="line">        tim = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[t:]:</span><br><span class="line">                <span class="built_in">sum</span> += i</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                    result_final.append(flag)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> result_final == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(result_final)</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            num = num + nums[end]</span><br><span class="line">            <span class="keyword">while</span> num &gt;= target:</span><br><span class="line">                result = <span class="built_in">min</span>(result,end - first+<span class="number">1</span>)</span><br><span class="line">                num = num - nums[first]</span><br><span class="line">                first += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> result == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>暴力求解（即解一），时间复杂度较高，会超出时间限制；</li><li>采用滑动窗口法（双指针法），两个指针一个指向所求区间尾端（end），另一个指向所求区间首段（first），根据题意要求的是最小的能使其和大于等于target的区间，因此当区间内和小于target时尾端应该右移，扩大区间，当区间内和大于等于target时，首端应右移，减少区间内元素个数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
