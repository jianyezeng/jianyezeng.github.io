<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信号与系统课程设计</title>
      <link href="blog/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>blog/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信号与系统课程设计"><a href="#信号与系统课程设计" class="headerlink" title="信号与系统课程设计"></a>信号与系统课程设计</h1><p>[TOC]</p><h2 id="图像处理-平滑、锐化与边缘提取"><a href="#图像处理-平滑、锐化与边缘提取" class="headerlink" title="图像处理(平滑、锐化与边缘提取)"></a>图像处理(平滑、锐化与边缘提取)</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>图像处理(image processing)，用计算机对图像进行分析，以达到所需结果的技术。又称影像处理。图像处理一般指数字图像处理。数字图像是指用工业相机、摄像机、扫描仪等设备经过拍摄得到的一个大的二维数组，该数组的元素称为像素，其值称为灰度值。图像处理技术一般包括图像压缩，增强和复原，匹配、描述和识别3个部分。</p><p>空间滤波是一种采用滤波处理的影像增强方法。目的是改善影像质量，包括去除高频噪声与干扰，及影像边缘增强、线性增强以及去模糊等。平滑和锐化滤波器是处理数字图像的常用方法。</p><p>平滑的主要目的是减少图像中的噪声。锐化的主要目的是突出图像中的细节或增强已经模糊的细节。</p><h3 id="图像平滑处理"><a href="#图像平滑处理" class="headerlink" title="图像平滑处理"></a>图像平滑处理</h3><p>图像在获取、传输的过程中，可能会受到干扰的影响，会产生噪声，噪声是一种出错了的信号，噪声会造成图像粗糙，需要我们对图像进行平滑处理，保留有用的信号。</p><p>在imgpr1.m，imgpr2.m中我们使用均值滤波、高斯滤波、中值滤波对img1，img2进行了平滑处理，分别得到三种结果，由于img1中存在椒盐干扰，因此中值滤波效果最好，对于img2则三种效果相似。</p><p>img1（最左为原图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232320952.png" alt="image-20230523232030867"></p><p>img2（最左为原图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232319447.png" alt="image-20230523231924542"></p><h3 id="图像锐化处理"><a href="#图像锐化处理" class="headerlink" title="图像锐化处理"></a>图像锐化处理</h3><p>图像锐化<em>(image sharpening)</em>是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰，图像锐化是为了突出图像上地物的边缘、轮廓，或某些线性目标要素的特征。这种滤波方法提高了地物边缘与周围像元之间的反差，因此也被称为边缘增强。</p><p>图像平滑往往使图像中的边界、轮廓变得模糊，为了减少这类不利效果的影响，这就需要利用图像锐化技术，使图像的边缘变的清晰。</p><p>公式推导：</p><script type="math/tex; mode=display">▽^2f=▽f(x+1)−▽f(x)\\▽f(x)=f(x+1)−f(x)\\</script><p>可得:    </p><script type="math/tex; mode=display">f(x)=f(x+1)−▽f(x)\\</script><p>则：</p><script type="math/tex; mode=display">f(x)=f(x+1)−▽f(x)+▽^2f(x)\\</script><p>那么锐化后的图像即为:</p><script type="math/tex; mode=display">g(x)=f(x+1)−▽f(x)+k▽^2f(x)\\</script><p>在不考虑精确度的情况下:</p><script type="math/tex; mode=display">g(x)=f(x)+k▽^2f(x)</script><p>在imgpr3.m中我们使用两种不同卷积核对img3进行了锐化处理（最左为原图）：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232320462.png" alt="image-20230523232048348"></p><h3 id="图像边缘提取"><a href="#图像边缘提取" class="headerlink" title="图像边缘提取"></a>图像边缘提取</h3><p>在imgpr4.m中，我们利用高斯滤波和canny算子，对img2进行了边缘提取：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305232321314.png" alt="image-20230523232154263"></p><h2 id="求图像中细胞平均半径"><a href="#求图像中细胞平均半径" class="headerlink" title="求图像中细胞平均半径"></a>求图像中细胞平均半径</h2><h3 id="原图"><a href="#原图" class="headerlink" title="原图"></a>原图</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026738.jpeg" alt="image"></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>图中很明显存在椒盐噪声（黑白点），因此首先使用中值滤波进行处理。</p><p>处理后：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026731.jpeg" alt="p1"></p><h4 id="高斯低通滤波与巴特沃斯低通滤波"><a href="#高斯低通滤波与巴特沃斯低通滤波" class="headerlink" title="高斯低通滤波与巴特沃斯低通滤波"></a>高斯低通滤波与巴特沃斯低通滤波</h4><p>之后使用傅里叶变换，将其转换到频域上，再进行后续操作：</p><ul><li>高斯低通滤波</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 读入原始图像</span></span><br><span class="line">img = imread(<span class="string">&#x27;p1.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对原始图像进行傅里叶变换</span></span><br><span class="line">F = fftshift(fft2(img));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 高斯低通滤波器参数</span></span><br><span class="line">D0 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 构造高斯低通滤波器</span></span><br><span class="line">[x, y] = <span class="built_in">meshgrid</span>(-(<span class="built_in">size</span>(img,<span class="number">1</span>)/<span class="number">2</span>):(<span class="built_in">size</span>(img,<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>), -(<span class="built_in">size</span>(img,<span class="number">2</span>)/<span class="number">2</span>):(<span class="built_in">size</span>(img,<span class="number">2</span>)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">dist = <span class="built_in">sqrt</span>(x.^<span class="number">2</span> + y.^<span class="number">2</span>);</span><br><span class="line">gauss_filter = <span class="built_in">exp</span>(-dist.^<span class="number">2.</span>/(<span class="number">2</span>*D0^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 滤波</span></span><br><span class="line">filtered_F = F .* gauss_filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 反变换</span></span><br><span class="line">filtered_img = uint8(<span class="built_in">real</span>(ifft2(ifftshift(filtered_F))));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示滤波前后的图像</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);imshow(img);title(<span class="string">&#x27;原始图像&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);imshow(filtered_img);title(<span class="string">&#x27;滤波后的图像&#x27;</span>);</span><br></pre></td></tr></table></figure><p>得到图像<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026807.png" alt="untitled"></p><ul><li>巴特沃斯低通滤波</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">p1 = imread(<span class="string">&#x27;p1.jpg&#x27;</span>);</span><br><span class="line">F=double(p1);<span class="comment">%数据类型转换，MATLAB不支特图像的无符号整型的i计算</span></span><br><span class="line">G = fft2(F);<span class="comment">%傅立叶变换</span></span><br><span class="line">G=fftshift(G);<span class="comment">%转换数据矩阵</span></span><br><span class="line">[M,N]=<span class="built_in">size</span>(G);</span><br><span class="line">nn=<span class="number">2</span>;<span class="comment">%二阶巴特沃斯(Butterworth)高通滤波器</span></span><br><span class="line">d0=<span class="number">30</span>;</span><br><span class="line">m=<span class="built_in">fix</span> (M/<span class="number">2</span>);n=<span class="built_in">fix</span>(N/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:M</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">        d=<span class="built_in">sqrt</span>((<span class="built_in">i</span>-m)^<span class="number">2</span>+(<span class="built_in">j</span>-n)^<span class="number">2</span>);</span><br><span class="line">        h=<span class="number">1</span>/(<span class="number">1</span>+<span class="number">0.414</span>*(d/d0)^(<span class="number">2</span>*nn));<span class="comment">%i计算传递函数</span></span><br><span class="line">        result(<span class="built_in">i</span>,<span class="built_in">j</span>) = h*G(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">result=ifftshift(result);</span><br><span class="line">Y2=ifft2(result);</span><br><span class="line">Y3=uint8(<span class="built_in">real</span>(Y2));</span><br><span class="line">subplot(<span class="number">121</span>),imshow(p1),title(<span class="string">&#x27;原图像&#x27;</span>);<span class="comment">%滤波后图像显示</span></span><br><span class="line">subplot(<span class="number">122</span>),imshow(Y3),title(<span class="string">&#x27;巴特沃斯低通滤波后图像&#x27;</span>);<span class="comment">%滤波后图像显示</span></span><br><span class="line"></span><br><span class="line">P_signal = sum(p1(:).^<span class="number">2</span>);</span><br><span class="line">P_noise_denoised = sum((Y3(:) - p1(:)).^<span class="number">2</span>);</span><br><span class="line">SNR_denoised = <span class="number">10</span>*<span class="built_in">log10</span>(P_signal/P_noise_denoised);</span><br><span class="line"><span class="built_in">disp</span>(SNR_denoised);</span><br></pre></td></tr></table></figure><p>得到图像<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026799.png" alt="untitled"></p><ul><li><p>两种滤波的比较</p><p>| 滤波   | 高斯低通滤波 | 巴特沃斯低通滤波 |<br>| ——— | —————— | ———————— |<br>| 信噪比 | 6.3678       | 5.1209           |</p><p>因此选择高斯低通滤波，之后进行逆傅里叶变换</p></li></ul><h4 id="其余预处理"><a href="#其余预处理" class="headerlink" title="其余预处理"></a>其余预处理</h4><ol><li>灰度化</li><li>直方图均衡化</li><li>低帽变换</li><li>调节灰度对比</li><li>二值化</li><li>形态学操作<ul><li>开操作</li><li>闭操作</li></ul></li></ol><h3 id="计算细胞半径"><a href="#计算细胞半径" class="headerlink" title="计算细胞半径"></a>计算细胞半径</h3><h4 id="hough圆形检测"><a href="#hough圆形检测" class="headerlink" title="hough圆形检测"></a>hough圆形检测</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 使用Hough变换进行圆形检测</span></span><br><span class="line">[centers, radii] = imfindcircles(BW3,[<span class="number">4</span>, <span class="number">20</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算细胞平均半径</span></span><br><span class="line">avgRadius = <span class="built_in">mean</span>(radii);</span><br><span class="line">sigma = std(radii);</span><br><span class="line">lower_threshold = avgRadius - <span class="number">2</span> * sigma;</span><br><span class="line">upper_threshold = avgRadius + <span class="number">2</span> * sigma;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 找到位于阈值内的所有元素</span></span><br><span class="line">idx = <span class="built_in">find</span>(radii &gt;= lower_threshold &amp; radii &lt;= upper_threshold);</span><br><span class="line">radii = radii(idx);</span><br><span class="line">centers = centers(idx,:);</span><br><span class="line">avgRadius = <span class="built_in">mean</span>(radii);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="comment">% 显示原始图像和检测结果</span></span><br><span class="line">imshow(p2); <span class="built_in">hold</span> on;</span><br><span class="line">h = viscircles(centers, radii,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">title([<span class="string">&#x27;Average cell radius: &#x27;</span>, num2str(avgRadius)]);</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026826.png" alt="untitled"></p><h4 id="bwlabel函数求半径"><a href="#bwlabel函数求半径" class="headerlink" title="bwlabel函数求半径"></a>bwlabel函数求半径</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 连通区域分析，计算每个细胞的面积和周长，并计算等效直径</span></span><br><span class="line">[L, num] = bwlabel(BW3);</span><br><span class="line">stats = regionprops(L, &#123;<span class="string">&#x27;Area&#x27;</span>, <span class="string">&#x27;Perimeter&#x27;</span>&#125;);</span><br><span class="line">diameters = <span class="built_in">zeros</span>(num, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : num</span><br><span class="line">    diameters(<span class="built_in">i</span>) = <span class="number">2</span> * <span class="built_in">sqrt</span>(stats(<span class="built_in">i</span>).Area / <span class="built_in">pi</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">boundaries = bwboundaries(BW3);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;The average diameter of cells is: &#x27;</span>, num2str(avg_diameter)]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="comment">% 画出每个细胞的轮廓</span></span><br><span class="line">imshow(BW3);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(boundaries)</span><br><span class="line">    boundary = boundaries&#123;<span class="built_in">i</span>&#125;;</span><br><span class="line">    <span class="built_in">plot</span>(boundary(:,<span class="number">2</span>), boundary(:,<span class="number">1</span>),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>结果如图所示</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305282026872.png" alt="untitled"></p><h4 id="两种结果对比"><a href="#两种结果对比" class="headerlink" title="两种结果对比"></a>两种结果对比</h4><ol><li>hough圆形检测法，对于部分形状不是圆的细胞，可能并不适用；</li><li>bwlabel函数求半径法，由于很多细胞重叠在一起，导致被认定为一个细胞，因此结果比较差。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于K-means算法的出行用户的分区</title>
      <link href="blog/%E5%9F%BA%E4%BA%8EK-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E8%A1%8C%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E5%8C%BA/"/>
      <url>blog/%E5%9F%BA%E4%BA%8EK-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BA%E8%A1%8C%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于K-means算法的出行用户的分区"><a href="#基于K-means算法的出行用户的分区" class="headerlink" title="基于K-means算法的出行用户的分区"></a>基于K-means算法的出行用户的分区</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某个打车平台的数据中心目前有 1000 位正在等待出行的顾客.现在已知每位顾客的出发地点的经度、纬度，到达地点的经度、纬度.这些数据保存在 data_customer.txt 文本文件中(位置数据是虚拟数据,并不一定完全符合实际).每行代表一个顾客的信息,依次表示出发地点经度、出发地点纬度、到达地点经度、到达地点纬度. 如果要把顾客出发地所在区域分为 10 个分区管理,请问每位顾客应分别分在哪个区,每个区的中心在哪里。</p><p><a href="https://camo.githubusercontent.com/7d6e21915df34fabe4a5c8a7d5d96de2bb1ac9a5561a3d1f2350b05dbabd1b74/68747470733a2f2f7a6a79696d6167652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f3230323330363230303035393430302e706e67"><img src="https://camo.githubusercontent.com/7d6e21915df34fabe4a5c8a7d5d96de2bb1ac9a5561a3d1f2350b05dbabd1b74/68747470733a2f2f7a6a79696d6167652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f3230323330363230303035393430302e706e67" alt="QQ截图20230620005735"></a></p><h2 id="聚类结果展示"><a href="#聚类结果展示" class="headerlink" title="聚类结果展示"></a>聚类结果展示</h2><p><a href="https://github.com/jianyezeng/some-practice-and-small-course-labs-or-assignments/blob/main/基于K-means算法的出行用户的分区/User_Partitions.m">代码与数据下载</a></p><p>基于K-means算法实现（matlab），效果如图所示：</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202307021426962.png" alt="结果"></h1><h2 id="代码实现（matlab）"><a href="#代码实现（matlab）" class="headerlink" title="代码实现（matlab）"></a>代码实现（matlab）</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">&#x27;data_customer.txt&#x27;</span>; </span><br><span class="line">data = importdata(filename); </span><br><span class="line">location = [data(:,<span class="number">1</span>:<span class="number">2</span>);data(:,<span class="number">3</span>:<span class="number">4</span>)];</span><br><span class="line">x = location(:,<span class="number">1</span>);</span><br><span class="line">y = location(:,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x,y,<span class="number">5</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,[<span class="number">0</span> <span class="number">.255</span> <span class="number">.5</span>]);</span><br><span class="line"></span><br><span class="line">K = <span class="number">10</span>;</span><br><span class="line">[idx, C] = kmeans(location, K,<span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">gscatter(location(:,<span class="number">1</span>), location(:,<span class="number">2</span>), idx);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(C(:,<span class="number">1</span>), C(:,<span class="number">2</span>), <span class="string">&#x27;kx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>,<span class="string">&#x27;DisplayName&#x27;</span>, <span class="string">&#x27;聚类中心&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1001 害死人不偿命的(3n+1)猜想</title>
      <link href="blog/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/"/>
      <url>blog/1001%20%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1001-害死人不偿命的-3n-1-猜想"><a href="#1001-害死人不偿命的-3n-1-猜想" class="headerlink" title="1001 害死人不偿命的(3n+1)猜想"></a>1001 害死人不偿命的(3n+1)猜想</h2><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805325918486528">题目详情 - 1001 害死人不偿命的(3n+1)猜想 (pintia.cn)</a></p><blockquote><p>卡拉兹(Callatz)猜想：</p><p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p><p><strong>输入格式：</strong>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p><p><strong>输出格式：</strong>输出从 <em>n</em> 计算到 1 需要的步数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            num = num/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> num = (<span class="number">3</span>*num+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1002 写出这个数</title>
      <link href="blog/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
      <url>blog/1002%20%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1002-写出这个数"><a href="#1002-写出这个数" class="headerlink" title="1002 写出这个数"></a>1002 写出这个数</h2><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805324509200384">题目详情 - 1002 写出这个数 (pintia.cn)</a></p><blockquote><p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><p><strong>输入格式：</strong>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p><p><strong>输出格式：</strong>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pand</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">switch</span>(x)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            str=<span class="string">&quot;ling&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            str=<span class="string">&quot;yi&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            str=<span class="string">&quot;er&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            str=<span class="string">&quot;san&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            str=<span class="string">&quot;si&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            str=<span class="string">&quot;wu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            str=<span class="string">&quot;liu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            str=<span class="string">&quot;qi&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            str=<span class="string">&quot;ba&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            str=<span class="string">&quot;jiu&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> numb;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; numb;</span><br><span class="line">    <span class="keyword">int</span> num[numb.size()];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numb.size();i++)&#123;</span><br><span class="line">        num[i] = <span class="keyword">int</span>(numb[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;record;</span><br><span class="line">    <span class="keyword">while</span> (sum/<span class="number">10</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">        record.insert(record.begin(),sum % <span class="number">10</span>);</span><br><span class="line">        sum = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    record.insert(record.begin(),sum % <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = record.begin();</span><br><span class="line">    <span class="keyword">for</span>(;it!=record.end()<span class="number">-1</span>;it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pand(*it)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pand(*it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1003 我要通过</title>
      <link href="blog/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/"/>
      <url>blog/1003%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1003-我要通过！"><a href="#1003-我要通过！" class="headerlink" title="1003 我要通过！"></a>1003 我要通过！</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805323154440192">题目详情 - 1003 我要通过！ (pintia.cn)</a></p><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p><p>得到“<strong>答案正确</strong>”的条件是：</p><ol><li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li><li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li><li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li></ol><p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (≤10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">PAT</span><br><span class="line">PAAT</span><br><span class="line">AAPATAA</span><br><span class="line">AAPAATAAAA</span><br><span class="line">xPATx</span><br><span class="line">PT</span><br><span class="line">Whatever</span><br><span class="line">APAAATAA</span><br><span class="line">APT</span><br><span class="line">APATTAA</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; judge(str)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag_p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">flag_t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span>::iterator it = str.begin();</span><br><span class="line">    <span class="keyword">while</span> (it !=str.end())&#123;</span><br><span class="line">        <span class="keyword">if</span> (*it!=<span class="string">&#x27;P&#x27;</span> &amp;&amp; *it!=<span class="string">&#x27;A&#x27;</span> &amp;&amp; *it!=<span class="string">&#x27;T&#x27;</span> &amp;&amp; *it!=<span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;A&#x27;</span>&amp;&amp; !flag_p)</span><br><span class="line">            count1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*it == <span class="string">&#x27;A&#x27;</span>&amp;&amp;flag_p&amp;&amp;!<span class="keyword">flag_t</span>)</span><br><span class="line">            count2++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*it == <span class="string">&#x27;A&#x27;</span>&amp;&amp;flag_p&amp;&amp;<span class="keyword">flag_t</span>)</span><br><span class="line">            count3++;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;P&#x27;</span>) flag_p ++;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;T&#x27;</span>) <span class="keyword">flag_t</span> ++;</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> ::iterator i = it;</span><br><span class="line">            i ++;</span><br><span class="line">            <span class="keyword">while</span>(*i != <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (*i != <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count3!=count2*count1 || flag_p!=<span class="number">1</span>||<span class="keyword">flag_t</span>!=<span class="number">1</span> || count2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1004 成绩排名</title>
      <link href="blog/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
      <url>blog/1004%20%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1004-成绩排名"><a href="#1004-成绩排名" class="headerlink" title="1004 成绩排名"></a>1004 成绩排名</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805321640296448">题目详情 - 1004 成绩排名 (pintia.cn)</a></p><p>读入 <em>n</em>（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第 1 行：正整数 n</span><br><span class="line">第 2 行：第 1 个学生的姓名 学号 成绩</span><br><span class="line">第 3 行：第 2 个学生的姓名 学号 成绩</span><br><span class="line">  ... ... ...</span><br><span class="line">第 n+1 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure><p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Joe Math990112 89</span><br><span class="line">Mike CS991301 100</span><br><span class="line">Mary EE990830 95</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mike CS991301</span><br><span class="line">Joe Math990112</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> stu_code;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    student stu[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; stu[i].name &gt;&gt; stu[i].stu_code &gt;&gt; stu[i].score;</span><br><span class="line">    student temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (stu[j].score &gt; stu[j+<span class="number">1</span>].score)&#123;</span><br><span class="line">                temp = stu[j];</span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu[n<span class="number">-1</span>].name &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;stu[n<span class="number">-1</span>].stu_code&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu[<span class="number">0</span>].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stu[<span class="number">0</span>].stu_code;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1005 继续（3n+1）猜想</title>
      <link href="blog/1005%20%E7%BB%A7%E7%BB%AD%EF%BC%883n+1%EF%BC%89%E7%8C%9C%E6%83%B3/"/>
      <url>blog/1005%20%E7%BB%A7%E7%BB%AD%EF%BC%883n+1%EF%BC%89%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1005-继续（3n-1）猜想"><a href="#1005-继续（3n-1）猜想" class="headerlink" title="1005 继续（3n+1）猜想"></a>1005 继续（3n+1）猜想</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805320306507776">题目详情 - 1005 继续(3n+1)猜想 (pintia.cn)</a></p><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 <em>n</em>=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 <em>n</em>=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 <em>n</em> 为“关键数”，如果 <em>n</em> 不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 5 6 7 8 11</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;record;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">auto</span> flag = find(v.begin(),v.end(),num);</span><br><span class="line">        <span class="keyword">if</span> (flag == v.end())&#123;</span><br><span class="line">            record.push_back(num);</span><br><span class="line">            <span class="keyword">while</span> (num!=<span class="number">1</span>)&#123;</span><br><span class="line">                v.push_back(num);</span><br><span class="line">                <span class="keyword">if</span> (num%<span class="number">2</span> == <span class="number">0</span>) num = num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> num = (<span class="number">3</span>*num+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">auto</span> fl  = find(record.begin(),record.end(),num);</span><br><span class="line">                <span class="keyword">if</span> (fl != record.end())</span><br><span class="line">                    record.erase(fl,fl+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(record.begin(), record.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = record.begin();</span><br><span class="line">    <span class="keyword">while</span> (it != record.end()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        it ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1007 素数对猜想</title>
      <link href="blog/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
      <url>blog/1007%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1007-素数对猜想"><a href="#1007-素数对猜想" class="headerlink" title="1007 素数对猜想"></a>1007 素数对猜想</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805317546655744">题目详情 - 1007 素数对猜想 (pintia.cn)</a></p><p>让我们定义$d<em>n$为：<em>$d_n$</em>=$p</em>{n+1}$−$p_n$，其中<em>p**i</em>是第<em>i</em>个素数。显然有$d_1$=1，且对于<em>n</em>&gt;1有<em>$d_n$</em>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;105)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><p><strong>输入格式:</strong></p><p>输入在一行给出正整数<code>N</code>。</p><p><strong>输出格式：</strong></p><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><p><strong>输入样例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="built_in">sqrt</span>(n))&#123;</span><br><span class="line">            <span class="keyword">if</span> (n%i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (judge(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-temp == <span class="number">2</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                temp = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li><p>素数又称质数；指除了 1 和它本身以外，不能被任何整数整除的数，例如17就是素数，因为它不能被 2~16 的任一整数整除。</p><ul><li>因此判断一个整数m是否是素数，只需把 m 被 2 ~ m-1 之间的每一个整数去除，如果都不能被整除，那么 m 就是一个素数。</li><li>判断方法还可以简化：m 不必被 2 ~ m-1 之间的每一个整数去除，只需被 2 ~$\sqrt{m}$ 之间的每一个整数去除就可以了。如果 m 不能被 2 ~$\sqrt{m}$  间任一整数整除，m 必定是素数。例如判别 17 是是否为素数，只需使 17 被 2~4 之间的每一个整数去除，由于都不能整除，可以判定 17 是素数。原因：因为如果 m 能被 2 ~ m-1 之间任一整数整除，其二个因子必定有一个小于或等于$\sqrt{m}$ ，另一个大于或等于 $\sqrt{m}$ 。例如 16 能被 2、4、8 整除，16=2<em>8，2 小于 4，8 大于 4，16=4</em>4，4=√16，因此只需判定在 2~4 之间有无因子即可。</li></ul></li><li><p>这个题较为简单，可以使用双指针法，一个指针i依次遍历，找到素数，另一个指针temp指向上一个素数，当指针i指向新的素数时，与temp指向的前一个素数比较，若大于2，则计数。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1006 换个格式输出整数</title>
      <link href="blog/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
      <url>blog/1006%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1006-换个格式输出整数"><a href="#1006-换个格式输出整数" class="headerlink" title="1006 换个格式输出整数"></a>1006 换个格式输出整数</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805318855278592">题目详情 - 1006 换个格式输出整数 (pintia.cn)</a></p><p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">234</span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BBSSS1234</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SS123</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        num.push_back(n%<span class="number">10</span>);</span><br><span class="line">        n = n/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = num.begin();</span><br><span class="line">    <span class="keyword">while</span> (it!=num.end())&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == num.begin()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = *it; i != <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str.insert(str.begin(), ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (it == num.begin()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=*it;i!=<span class="number">0</span>;i--)</span><br><span class="line">                str.insert(str.begin(),<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=*it;i!=<span class="number">0</span>;i--)</span><br><span class="line">                str.insert(str.begin(),<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        it ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol><li>C++的STL标准模版库中string插入元素：insert(it,ch)，其中it为迭代器，ch为插入的字符；</li><li>将数字转换为字符，可以通过在字符字面量前加单引号来创建一个字符。为了将数字 4 转换为字符 ‘4’，可以利用数字字符的 ASCII 码值，将其转换为对应的字符。例如，字符 ‘0’ 的 ASCII 码值为 48，字符 ‘1’ 的 ASCII 码值为 49，以此类推。因此，字符 ‘4’ 的 ASCII 码值为 52。要将数字 4 转换为字符 ‘4’，只需要将其 ASCII 码值加上字符 ‘0’ 的 ASCII 码值，即可得到字符 ‘4’ 的 ASCII 码值，然后将其转换为字符即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1008 数组元素循环右移问题</title>
      <link href="blog/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
      <url>blog/1008%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1008-数组元素循环右移问题"><a href="#1008-数组元素循环右移问题" class="headerlink" title="1008 数组元素循环右移问题"></a>1008 数组元素循环右移问题</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805316250615808">题目详情 - 1008 数组元素循环右移问题 (pintia.cn)</a></p><p>一个数组<em>A</em>中存有<em>N</em>（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移<em>M</em>（≥0）个位置，即将<em>A</em>中的数据由（<em>A</em>0<em>A</em>1⋯<em>A**N</em>−1）变换为（<em>A**N</em>−<em>M</em>⋯<em>A**N</em>−1<em>A</em>0<em>A</em>1⋯<em>A**N</em>−<em>M</em>−1）（最后<em>M</em>个数循环移至最前面的<em>M</em>个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p><strong>输入格式:</strong></p><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p><p><strong>输出格式:</strong></p><p>在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p><strong>输入样例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 6 1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">int</span> n =<span class="number">0</span>,m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lis = v[j];</span><br><span class="line">        <span class="keyword">int</span> ori = j;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            j = (j+m)%n;</span><br><span class="line">            temp = v[j];</span><br><span class="line">            v[j] = lis;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            lis = temp;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(j!=ori&amp;&amp;count&lt;=n);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;n)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin();</span><br><span class="line">    <span class="keyword">while</span> (it != v.end()<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;*it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串</title>
      <link href="blog/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>blog/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串 - 力扣（LeetCode）</a></p><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[<span class="built_in">str</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            temp = s[left]</span><br><span class="line">            s[left] = s[right]</span><br><span class="line">            s[right] = temp</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>可以使用了双指针法，反转字符串即为字符串中$s[n-i-1]$与$s[i]$交换位置，因此可以使用两个指针left，right，一个在首端，一个在尾端，当left&lt;right时，交换两个指针对应节点</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左旋转字符串</title>
      <link href="blog/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>blog/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><blockquote><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">st</span><span class="params">(n,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;n) st[i] = s[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.size()-n) s[i] = s[i+n];</span><br><span class="line">            <span class="keyword">else</span> s[i] = st[i+n-s.size()];</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.begin()+n);</span><br><span class="line">        reverse(s.begin()+n,s.end());</span><br><span class="line">        reverse(s.begin(),s.end());            </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>解一遍历整个字符串，首先将需要旋转至尾部的部分存到新的字符串中，字符串后面的部分前移，当遍历至已经前移过的部位时，将存在新字符串中的需要选择至尾部的部分提取并赋值；</p></li><li><p>解二采用局部反转+整体反转的思路；<strong>具体步骤为</strong>：<strong>反转</strong>区间为 <code>前n</code> 的子串；<strong>反转</strong>区间为<code>n</code> 到<code>末尾</code>的子串；<strong>反转</strong> 整个字符串（如下图所示）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202306141910905.png" alt="1685707897-lpxpas-604020381907e149b88d0892cfb11d0"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="blog/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>blog/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解一"><a href="#解一" class="headerlink" title="解一"></a>解一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span>::iterator it = s.begin();</span><br><span class="line">        <span class="keyword">while</span> (it!= s.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                it = s.replace(it,it+<span class="number">1</span>,<span class="string">&quot;%20&quot;</span>).begin()+<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> it += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = s.size()+count*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = s.size()+count*<span class="number">2</span> ;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">st</span><span class="params">(num,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (;p2 &gt;= <span class="number">0</span>;p2--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[p2]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                st[p1] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                st[p1<span class="number">-1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                st[p1<span class="number">-2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                p1 -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st[p1] = s[p2];</span><br><span class="line">                p1--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一使用了C++的STL标准模版库中string容器的一些方法，从而实现替换字符串中空格；</li><li>解二使用了双指针法，首先对字符串中空格进行计数，之后设置两个指针分别指向两个字符串末端（一个字符串为原字符串，另一个为新字符串，长度可根据原字符串长度和空格数目计算），之后以此前移，原字符串的指针指向空格时，新字符串指针替换成“%20”，且多前移2位，直至两指针均指向字符串首端；</li><li>字符串的size()函数输出的是一个unsigned int类型的值，unsigned int类型的值不支持负数。因此若一个unsigned int类型的数字0，减1后得到的是$2^{32}-1$，而非-1。在计算字符串长度时，应该统一使用unsigned int类型进行计算，避免出现负数情况。在循环条件中i&lt;=s.size()-1与i&lt;s.size()是等价的，但最好用后者，避免出现unsigned int（0-1）的情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="blog/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>blog/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p><blockquote><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = i+<span class="number">1</span></span><br><span class="line">                right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[left] + nums[right] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> [nums[i],nums[left],nums[right]] <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                            result.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        record = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> k,m <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> i != k:</span><br><span class="line">                    <span class="built_in">sum</span> = j+m</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">in</span> record:</span><br><span class="line">                        record[<span class="built_in">sum</span>].append([i,k])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        record[<span class="built_in">sum</span>] = [[i,k]]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> -nums[i] <span class="keyword">in</span> record:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> record[-nums[i]]:</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> x:</span><br><span class="line">                        ans = <span class="built_in">sorted</span>([nums[x[<span class="number">0</span>]],nums[x[<span class="number">1</span>]],nums[i]])</span><br><span class="line">                        <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                            result.append(ans)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一使用排序+双指针的方法，首先对原列表进行排序，之后设置left，right两个指针，遍历列表，left，right位置分别设置为i+1，n-1，当i，left，right元素之和小于0时，left右移，当和大于0时，right左移，当为0时，检查这个三元组是否在result中出现过，若未出现，则加入result；</li><li>解二使用字典实现哈希表，哈希表键为两个元素之和，值为对应两个元素的位置，之后遍历列表找第三个元素，需要注意，在找第三个元素时，不仅要使得三元素之和为0，还要保证三元组未在result中出现过，因此可以在将和0的三元组放入result前先对其进行排序，检查是否已出现过，未出现则放入，已出现，则丢弃。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个数组的交集</title>
      <link href="blog/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>blog/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣</a></p><blockquote><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><p>示例 1：</p><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                num[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> num:</span><br><span class="line">                num[i] = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> num.items():</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s1, s2 = <span class="built_in">set</span>(nums1), <span class="built_in">set</span>(nums2)</span><br><span class="line">        result = [val <span class="keyword">for</span> val <span class="keyword">in</span> s1 <span class="keyword">if</span> val <span class="keyword">in</span> nums2]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一使用了字典实现哈希表，但是需要注意字典实现哈希表的时间复杂度更大；</li><li>解二直接将两个列表转换为两个字典，遍历一遍即可，但这种时间复杂度较高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四数相加2</title>
      <link href="blog/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A02/"/>
      <url>blog/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="四数相加2"><a href="#四数相加2" class="headerlink" title="四数相加2"></a>四数相加2</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II - 力扣（LeetCode）</a></p><blockquote><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;= i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>], nums3: List[<span class="built_in">int</span>], nums4: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        sum_ab =&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="built_in">sum</span> = i+j</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">in</span> sum_ab:</span><br><span class="line">                    sum_ab[<span class="built_in">sum</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum_ab[<span class="built_in">sum</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="built_in">sum</span> = i+j</span><br><span class="line">                <span class="keyword">if</span> -<span class="built_in">sum</span> <span class="keyword">in</span> sum_ab:</span><br><span class="line">                    count += sum_ab[-<span class="built_in">sum</span>]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>​    将四个列表分成两组，用字典实现哈希表，记录nums1和nums2中元素之和出现的次数，之后再对nums3和nums4进行遍历，找到nums3和nums4元素之和sum对应的-sum是否在哈希表中出现过，若出现过，则哈希表中的值即为对应次数。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="blog/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>blog/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 - 力扣（LeetCode）</a></p><blockquote><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>快乐数定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getsum</span>(<span class="params">n</span>):</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="built_in">sum</span> += (n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">                n = n//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">        record = <span class="built_in">set</span>()</span><br><span class="line">        <span class="built_in">sum</span> = getsum(n)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">sum</span> != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">                record.add(<span class="built_in">sum</span>)</span><br><span class="line">                n = <span class="built_in">sum</span></span><br><span class="line">                <span class="built_in">sum</span> = getsum(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getsum</span>(<span class="params">n</span>):</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n:</span><br><span class="line">                <span class="built_in">sum</span> += (n%<span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">                n = n//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">        slow_runner = n</span><br><span class="line">        fast_runner = getsum(n)</span><br><span class="line">        <span class="keyword">while</span> fast_runner != <span class="number">1</span> <span class="keyword">and</span> slow_runner != fast_runner:</span><br><span class="line">            slow_runner = getsum(slow_runner)</span><br><span class="line">            fast_runner = getsum(getsum(fast_runner))</span><br><span class="line">        <span class="keyword">return</span> fast_runner == <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>对于这道题，结果有三种可能：</p><ul><li>sum出现1</li><li>进入循环</li><li>值越来越大，趋近于无穷大，没有进入循环</li></ul><p>但是经过观察，三位数字最大999，其sum也只是243，之后产生的值均小于等于243，因此不会出现第三种情况；</p></li><li><p>解一使用哈希集合检测循环，当新获得的sum已出现在集合中，则说明发生了循环；</p></li><li><p>解二使用了快慢指针法，当需要检测循环时，就可以使用快慢指针法，快指针速度是慢指针的2倍，因此若发生循环，则两者必定相遇；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的字母异位词</title>
      <link href="blog/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>blog/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词 - 力扣（LeetCode）</a></p><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>示例 1:</p><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a, b = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> a:</span><br><span class="line">                a[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> b:</span><br><span class="line">                b[t[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b[t[i]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        record = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            record[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            record[<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> record.count(<span class="number">0</span>) == <span class="number">26</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> a:</span><br><span class="line">                a[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> a:</span><br><span class="line">                a[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a.values():</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一直接将两个字符串的对应信息存储在两个字典中，之后通过判断两个字典是否相同来判断两个字符串是否为字母异位词；</li><li>解二使用了哈希表，二十六个字母分别映射到列表中的一个位置中去，原列表元素全为0，对于第一个字符串，每遍历一个字母，其对应位置的列表元素+1，之后对于第二个字符串，每遍历一个字母，其对应位置的列表元素-1，若最终列表中元素仍全为0，则说明两个字符串为字母异位词；</li><li>受解二的启发，联想到，解一的字典实际上与解二的列表发挥的作用是一致的，因此可以对解一进行改进，如解三所示，利用字典实现了哈希表（与解二不同的是由字符串到哈希表的映射关系）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赎金信</title>
      <link href="blog/%E8%B5%8E%E9%87%91%E4%BF%A1/"/>
      <url>blog/%E8%B5%8E%E9%87%91%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信 - 力扣（LeetCode）</a></p><blockquote><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>字典实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        record = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> record:</span><br><span class="line">                record[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">                record[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> record[i] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>列表实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        record = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            record[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            record[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> record[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>​    采用哈希表的解法，首先将magazine的字母出现次数存在一个哈希表中，再遍历resomNote的字母，每遍历一个，将哈希表中对应出现次数-1，若哈希表出现负值或哈希表中无该字母，则说明无法构成，反之，可以构成。因为题目限制，只能是小写字母，因此也可以选择用长度为26的列表实现。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML_convid-19感染人群占比预测</title>
      <link href="blog/%E6%9D%8E%E5%AE%8F%E6%AF%85ML_convid-19%E6%84%9F%E6%9F%93%E4%BA%BA%E7%BE%A4%E5%8D%A0%E6%AF%94%E9%A2%84%E6%B5%8B/"/>
      <url>blog/%E6%9D%8E%E5%AE%8F%E6%AF%85ML_convid-19%E6%84%9F%E6%9F%93%E4%BA%BA%E7%BE%A4%E5%8D%A0%E6%AF%94%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="李宏毅ML-convid-19感染人群占比预测"><a href="#李宏毅ML-convid-19感染人群占比预测" class="headerlink" title="李宏毅ML_convid-19感染人群占比预测"></a>李宏毅ML_convid-19感染人群占比预测</h2><h3 id="目标与数据集下载"><a href="#目标与数据集下载" class="headerlink" title="目标与数据集下载"></a>目标与数据集下载</h3><p>来源：<a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.php">ML 2021 Spring (ntu.edu.tw)</a></p><p>目标：预测第三天美国某周感染人数占比</p><p>数据集下载：<a href="https://www.kaggle.com/competitions/ml2021spring-hw1/data">ML2021Spring-hw1 | Kaggle</a></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader, random_split</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机种子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same_seed</span>(<span class="params">seed</span>):</span> </span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        torch.cuda.manual_seed_all(seed)</span><br><span class="line">same_seed(config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数+device，方便调节</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&#x27;valid_ratio&#x27;</span> : <span class="number">0.2</span>,</span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>:<span class="number">5121014</span>,</span><br><span class="line">    <span class="string">&#x27;select_all&#x27;</span>:<span class="literal">True</span>,</span><br><span class="line">    <span class="string">&#x27;batch_size&#x27;</span>:<span class="number">256</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>:<span class="number">1e-3</span>,</span><br><span class="line">    <span class="string">&#x27;n_epochs&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;save_path&#x27;</span>:<span class="string">&#x27;./models/model.ckpt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;early_stop&#x27;</span>:<span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据模块</span></span><br><span class="line"><span class="comment"># 划分训练集与验证集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_valid_set</span>(<span class="params">data_set, valid_ratio, seed</span>):</span></span><br><span class="line">    valid_set_size = <span class="built_in">int</span>(valid_ratio * <span class="built_in">len</span>(data_set)) </span><br><span class="line">    train_set_size = <span class="built_in">len</span>(data_set) - valid_set_size</span><br><span class="line">    train_set, valid_set = random_split(data_set, [train_set_size, valid_set_size],  generator=torch.Generator().manual_seed(seed))</span><br><span class="line">    <span class="keyword">return</span> np.array(train_set), np.array(valid_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据集    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">convid19Dataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.y = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = torch.FloatTensor(y)</span><br><span class="line">        self.x = torch.FloatTensor(x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx],self.y[idx]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.x)</span><br><span class="line"><span class="comment"># 选择特征值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_feather</span>(<span class="params">train_data,valid_data,test_data,select_all = <span class="literal">True</span></span>):</span></span><br><span class="line">    y_train,y_valid = train_data[:,-<span class="number">1</span>],valid_data[:,-<span class="number">1</span>]</span><br><span class="line">    raw_x_train,raw_x_valid,raw_x_test = train_data[:,<span class="number">1</span>:-<span class="number">1</span>],valid_data[:,<span class="number">1</span>:-<span class="number">1</span>],test_data[:,<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> select_all:</span><br><span class="line">        feat_idx = <span class="built_in">list</span>(<span class="built_in">range</span>(raw_x_train.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        feat_idx = [] <span class="comment">#待选择</span></span><br><span class="line">    <span class="keyword">return</span> raw_x_train[:,feat_idx],raw_x_valid[:,feat_idx], raw_x_test[:,feat_idx], y_train, y_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取数据</span></span><br><span class="line">train_data,test_data = pd.read_csv(<span class="string">&#x27;./covid.train.csv&#x27;</span>).values,pd.read_csv(<span class="string">&#x27;./covid.test.csv&#x27;</span>).values</span><br><span class="line">train_data,valid_data = train_valid_set(train_data,config[<span class="string">&#x27;valid_ratio&#x27;</span>],config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line">print(<span class="string">f&#x27;&#x27;&#x27;train_data_size:<span class="subst">&#123;train_data.shape&#125;</span></span></span><br><span class="line"><span class="string">valid_data_size:<span class="subst">&#123;valid_data.shape&#125;</span></span></span><br><span class="line"><span class="string">test_data_size:<span class="subst">&#123;test_data.shape&#125;</span>&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得数据集</span></span><br><span class="line">x_train,x_valid,x_test,y_train,y_valid = select_feather(train_data,valid_data,test_data,config[<span class="string">&#x27;select_all&#x27;</span>])</span><br><span class="line">print(<span class="string">f&quot;number of feathers:<span class="subst">&#123;x_train.shape&#125;</span>&quot;</span>)</span><br><span class="line">train_dataset,valid_dataset,test_dataset = convid19Dataset(x_train,y_train),\</span><br><span class="line">                                        convid19Dataset(x_valid,y_valid),\</span><br><span class="line">                                        convid19Dataset(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataLoader</span></span><br><span class="line">train_dataloader = DataLoader(train_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">True</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line">valid_dataloader = DataLoader(valid_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">True</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_dataset,batch_size = config[<span class="string">&#x27;batch_size&#x27;</span>],shuffle = <span class="literal">False</span>,pin_memory = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络结构模块</span></span><br><span class="line"><span class="comment"># 定义网络结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,input_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(My_model,self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.layers = nn.Sequential(</span><br><span class="line">            nn.Linear(input_dim,<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">32</span>,<span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">16</span>,<span class="number">8</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">8</span>,<span class="number">1</span>),</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.layers(x)</span><br><span class="line">        x = x.squeeze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 训练模块</span></span><br><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainer</span>(<span class="params">train_loader,valid_loader,model,config,device</span>):</span></span><br><span class="line">    criterion = nn.MSELoss(reduction = <span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(),lr = config[<span class="string">&#x27;learning_rate&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    writer = SummaryWriter()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">&#x27;./models&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./models&#x27;</span>)</span><br><span class="line">    n_epochs,best_loss,step,early_stop_count = config[<span class="string">&#x27;n_epochs&#x27;</span>],math.inf,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">        model.train()</span><br><span class="line">        loss_record = []</span><br><span class="line">        train_pbar = tqdm(train_loader,leave = <span class="literal">True</span>,position = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> train_pbar:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            x,y = x.to(device),y.to(device)</span><br><span class="line">            pred = model(x)</span><br><span class="line">            loss = criterion(pred,y)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">            loss_record.append(loss.detach().item())</span><br><span class="line">            </span><br><span class="line">            train_pbar.set_description(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]&#x27;</span>)</span><br><span class="line">            train_pbar.set_postfix(&#123;<span class="string">&#x27;loss&#x27;</span>:loss.detach().item()&#125;)</span><br><span class="line">        </span><br><span class="line">        mean_train_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/train&#x27;</span>,mean_train_loss,step)</span><br><span class="line"></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        loss_record = []</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> valid_loader:</span><br><span class="line">            x,y = x.to(device),y.to(device)</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                pred = model(x)</span><br><span class="line">                loss = criterion(pred,y)</span><br><span class="line">            loss_record.append(loss.item())</span><br><span class="line">        mean_valid_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        print(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]: Train loss: <span class="subst">&#123;mean_train_loss:<span class="number">.4</span>f&#125;</span>, Valid loss: <span class="subst">&#123;mean_valid_loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/valid&#x27;</span>,mean_valid_loss,step)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> mean_valid_loss &lt;best_loss:</span><br><span class="line">            best_loss = mean_valid_loss</span><br><span class="line">            torch.save(model.state_dict(),config[<span class="string">&#x27;save_path&#x27;</span>])</span><br><span class="line">            print(<span class="string">&#x27;Saving model with loss &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_loss))</span><br><span class="line">            early_stop_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            early_stop_count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> early_stop_count &gt;= config[<span class="string">&#x27;early_stop&#x27;</span>]:</span><br><span class="line">            print(<span class="string">&#x27;\nModel is not improving, so we halt the training session.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">model = My_model(input_dim = x_train.shape[<span class="number">1</span>]).to(device)</span><br><span class="line">trainer(train_dataloader,valid_dataloader,model,config,device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示训练过程的loss变化</span></span><br><span class="line">%reload_ext tensorboard</span><br><span class="line">%tensorboard --logdir=./runs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测模块</span></span><br><span class="line"><span class="comment"># 保存预测值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_pred</span>(<span class="params">preds,file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        writer = csv.writer(fp)</span><br><span class="line">        writer.writerow([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;tested_positive&#x27;</span>])</span><br><span class="line">        <span class="keyword">for</span> i,p <span class="keyword">in</span> <span class="built_in">enumerate</span>(preds):</span><br><span class="line">            writer.writerow([i,p])</span><br><span class="line"><span class="comment"># 预测函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">test_loader,model,device</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    preds=[]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">        x = x.to(device)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            pred = model(x)</span><br><span class="line">            preds.append(pred.detach().cpu())</span><br><span class="line">    preds = torch.cat(preds,dim = <span class="number">0</span>).numpy()</span><br><span class="line">    <span class="keyword">return</span> preds </span><br><span class="line"><span class="comment"># 进行预测            </span></span><br><span class="line">model = My_model(input_dim = x_train.shape[<span class="number">1</span>]).to(device)</span><br><span class="line">model.load_state_dict(torch.load(config[<span class="string">&#x27;save_path&#x27;</span>]))</span><br><span class="line">preds = predict(test_dataloader,model,device)</span><br><span class="line">save_pred(preds,<span class="string">&#x27;pred.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pytorch项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> pytorch </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 机器学习基本概念</title>
      <link href="blog/01%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>blog/01%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h2><blockquote><p>机器学习就是让机器具备找一个函数的能力</p></blockquote><h3 id="机器学习的任务"><a href="#机器学习的任务" class="headerlink" title="机器学习的任务"></a>机器学习的任务</h3><ol><li><p>Regression:函数输出是一个数值，例如：</p><ul><li>预测某一时间PM2.5的数值</li></ul></li><li><p>Classification:做选择题，从设置好的答案中选择正确的当作输出，例如：</p><ul><li>判断垃圾邮件，输出为 是 与 不是 中的一个</li><li>阿尔法狗，输出为棋盘上剩余位置中的一个</li></ul></li><li><p>Structured Learning：输出有结构性的结果，例如：</p><ul><li>创造一篇文章</li><li>画一个图</li></ul></li></ol><h3 id="训练（如何找到一个函数）"><a href="#训练（如何找到一个函数）" class="headerlink" title="训练（如何找到一个函数）"></a>训练（如何找到一个函数）</h3><ol><li><p>Function with Unkown Parameters(写出一个带有未知参数的函数)</p><p>依靠Demain knowledge(即对问题的理解)，先简单猜测一下输入输出之间的关系，写出带有未知参数的函数(或许可以用下最小二乘法)</p></li><li><p>Define Loss from Training Data(判断原有模型的好坏)</p><p>定义Loss为一个可以评判模型好坏的标准，可以通过训练资料得到Loss，例如将Loss设为每次推测结果与实际结果之间差的绝对值的平均数</p></li><li><p>Optimization（最优化）</p><p>找到最好的位置参数（即找到可使得Loss最小的未知参数）；可采用梯度下降法</p></li></ol><h3 id="更有弹性的模型"><a href="#更有弹性的模型" class="headerlink" title="更有弹性的模型"></a>更有弹性的模型</h3><h4 id="使用sigmoid建立一个更有弹性的模型"><a href="#使用sigmoid建立一个更有弹性的模型" class="headerlink" title="使用sigmoid建立一个更有弹性的模型"></a>使用sigmoid建立一个更有弹性的模型</h4><p>可以用Piecewise Linear 的Curves逼近任何连续曲线（即用折线逼近曲线），而Piecewise Linear的Curves是由多个function（相当于折线图中每一个直线）相加得到的，function又可以利用sigmoid逼近得到（当然也可以用其他函数逼近）</p><p>sigmoid:</p><script type="math/tex; mode=display">y = c/(1+e^{-(b+wx_1)})</script><p>即</p><script type="math/tex; mode=display">y = c*sigmoid(b+wx_1)</script><p>可根据不同的w，b, c调整sigmoid。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118353.png" alt="QQ截图20230420164915"></p><p>拟合得到的曲线函数：</p><script type="math/tex; mode=display">y = b + \sum_ic_i *sigmoid(b_i+w_ix_i)</script><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118354.png" alt="QQ截图"></p><p>如上图所示，可将逼近曲线的过程转换为线性代数的表达，其中b（标量），$c^T$, b(向量)， W均为未知参数，可将这些未知参数拼成一个向量$\theta$;由此我们已经得到了一个函数，接下来需要进行训练的第2、3步:</p><p>Loss是一个关于$\theta$的函数，即L($\theta$)（至于如何定义L，可根据题目需要进行），而对其进行优化的过程与前面线性模型的方法基本相同（梯度下降法）。</p><h4 id="epoch与update的概念"><a href="#epoch与update的概念" class="headerlink" title="epoch与update的概念"></a>epoch与update的概念</h4><p>事实上，在做Optimization时，并不是一次将全部的资料都拿来训练，而是将其随机分为几份batch（至于到底几个batch自己定义），每次用一份batch进行训练，对$\theta$进行更新，而将全部资料都训练一次，称为一个epoch，每次用一个batch进行训练，称为一个update；</p><h4 id="ReLU-与sigmoid均为Activation-function的一种"><a href="#ReLU-与sigmoid均为Activation-function的一种" class="headerlink" title="ReLU(与sigmoid均为Activation function的一种)"></a>ReLU(与sigmoid均为Activation function的一种)</h4><p>除了sigmoid外，我们还可以利用其他函数来达到逼近的目的，例如ReLU</p><script type="math/tex; mode=display">c*max(0,b+wx_i)</script><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118355.png" alt="QQ截图20230422122016">在机器学习中，我们称sigmoid、ReLU这类函数为Activation function。</p><h4 id="继续改进模型，得到Deep-Learning"><a href="#继续改进模型，得到Deep-Learning" class="headerlink" title="继续改进模型，得到Deep Learning"></a>继续改进模型，得到Deep Learning</h4><p>我们可以多做几次从x到a的过程<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118356.png" alt="QQ截图20230422121803"></p><p>每一个sigmoid或者ReLU都是一个Neuron(神经元),这也就是一个神经网络模型。后来，又称每一个Neuron为一个layer，如何一个模型有很多个layer，我们就将其称为Deeping Learning。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 模型训练过程中可能出现的问题</title>
      <link href="blog/02%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>blog/02%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模型训练过程中可能出现的问题"><a href="#模型训练过程中可能出现的问题" class="headerlink" title="模型训练过程中可能出现的问题"></a>模型训练过程中可能出现的问题</h2><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118253.png" alt="QQ截图20230422123240"></p><h3 id="Loss-on-training-data-较大"><a href="#Loss-on-training-data-较大" class="headerlink" title="Loss on training data 较大"></a>Loss on training data 较大</h3><h4 id="model-bias"><a href="#model-bias" class="headerlink" title="model bias"></a>model bias</h4><ol><li><strong>原因</strong>：模型太过于简单，弹性不够。</li><li><strong>解决方法</strong>：重新设计模型，让模型更有弹性。</li></ol><h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><p><strong>原因</strong>：优化方法不够好。</p><h4 id="如何区分model-bias与optimization？"><a href="#如何区分model-bias与optimization？" class="headerlink" title="如何区分model bias与optimization？"></a>如何区分model bias与optimization？</h4><p>先训练些比较简单的model，再训练比较复杂的model，如果较复杂的model结果反而不如较简单的，就说明是optimization出了问题。</p><h3 id="Loss-on-training-data-较小"><a href="#Loss-on-training-data-较小" class="headerlink" title="Loss on training data 较小"></a>Loss on training data 较小</h3><h4 id="overfitting"><a href="#overfitting" class="headerlink" title="overfitting"></a>overfitting</h4><p>模型训练结果越来越好，但预测结果在达到一定程度后越来越差。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118254.png" alt="QQ截图20230422125629"></p><ol><li><strong>原因</strong>：模型太复杂，太灵活了。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118255.png" alt="QQ截图20230422125356"></li><li><strong>解决方法</strong>：<ul><li>使用更多训练资料（不建议）；</li><li>Data augmentation（对已有资料进行处理，得到更多资料，例如将照片镜像）；</li><li>给模型加上一些限制。</li></ul></li></ol><h4 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118256.png" alt="QQ截图20230422130221">    训练资料与测试资料差异较大</p><h3 id="如何选择模型"><a href="#如何选择模型" class="headerlink" title="如何选择模型"></a>如何选择模型</h3><p>​    可以将自己的资料分成多份，分别作为训练资料和预测资料，以选择最好的模型。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 训练神经网络的一些tips</title>
      <link href="blog/03%20%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9Btips/"/>
      <url>blog/03%20%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9Btips/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="训练神经网络的一些tips"><a href="#训练神经网络的一些tips" class="headerlink" title="训练神经网络的一些tips"></a>训练神经网络的一些tips</h1><h2 id="local-minima-and-saddle-point"><a href="#local-minima-and-saddle-point" class="headerlink" title="local minima and saddle point"></a>local minima and saddle point</h2><p>前面已经说过了，当模型训练结的Loss过大时，可能是模型本身的原因（model bias）和optimization过程没有做好，那么如何改良optimization过程呢？</p><p>首先我们要知道optimization出现问题很可能是遇到了critical point。</p><p><strong>critical point</strong>( 临界点，gradient 为 0)</p><ul><li><p>local minima （梯度为0且是局部最低点）</p></li><li><p>saddle point  （梯度为0但并不是局部最低点）</p></li></ul><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113225.JPG" alt="捕获"></p><p><strong>如何去辨别是哪一种critical point？</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113226.PNG" alt="捕获"></p><p>当位于临界点时，g（梯度）为0，可以认为</p><script type="math/tex; mode=display">L(\theta) = L(\theta^. )+1/2(\theta-\theta^.)^TH(\theta-\theta^.)</script><p>之后可以根据H判断是哪种临界点；</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113227.PNG" alt="捕"></p><p>当临界点为saddle point时的做法</p><p>我们可以根据H去更新$\theta$</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052113228.PNG" alt="001"></p><p>Local minima 在更高级的维度中或许也是 一个saddle point。</p><h2 id="Batch-and-Momentum"><a href="#Batch-and-Momentum" class="headerlink" title="Batch and Momentum"></a>Batch and Momentum</h2><h3 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h3><p>将资料分成多个Batch的过程，常见的做法是在每一个Epoch之前分一次Batch，每一次的Batch都不一样。</p><h3 id="为什么要采用Batch"><a href="#为什么要采用Batch" class="headerlink" title="为什么要采用Batch"></a>为什么要采用Batch</h3><p>时间？事实上，因为有平行运算的原因，large Batch（例如只分出1个Batch）在时间上往往要比small Batch更占优势（超大数据集除外）</p><p>答案是small Batch的Optimization做的更好，small Batch的update过程是更noisy的，但恰恰是更noisy更有利于optimization的。为什么呢？因为如果是large batch，在update过程中遇到一个local minima或者saddle point就停下来了，而对于small batch，由于每次训练采用的数据集不同，因此function也不同，当一个function遇到local minima或者saddle point停下来了，却不会影响另一个function。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625355.png" alt="batch"></p><p>除此之外，small Batch也更有利于预测（或测试），其原因尚有争论，有一个观点是small Batch更有利于遇到flat minima,而large Batch更倾向于进入sharp minima。（flat minima指周围梯度绝对值较小的点，而sharp minima则与之相反，由于测试的数据集与训练的数据集可能存在差别，flat minima显然更有包容性，而small Batch在遇到sharp minima时，更有可能跳出去，因此测试结果更好）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625196.png" alt="good-bad-local"></p><p><strong>small Batch 与 large Batch对比</strong>：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625295.png" alt="s-b对比"></p><h3 id="momentum"><a href="#momentum" class="headerlink" title="momentum"></a>momentum</h3><p>每次$\theta$的移动并不是只考虑gradient ，而是考虑过去所有gradient的总和。</p><p>即每次移动的方向为梯度反方向+原来移动方向</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625285.png" alt="mumentum"></p><p> 这种方法的好处是可以有效避免local minima和saddle point（可以类比一下惯性)。<img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101625228.png" alt="mu"></p><h2 id="自动调整学习速率"><a href="#自动调整学习速率" class="headerlink" title="自动调整学习速率"></a>自动调整学习速率</h2><h3 id="不变的learning-rate存在的问题："><a href="#不变的learning-rate存在的问题：" class="headerlink" title="不变的learning rate存在的问题："></a>不变的learning rate存在的问题：</h3><ol><li><p>如果learning rate比较大，可能无论如何都无法到达最低点，而是在最低点旁左右横条</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626991.png" alt="rate large"></p></li><li><p>如果learning rate比较小，问题1得到一定程度的解决，但是当grandient比较大时，移动的还比较快，当grandient比较小时，就会出现移动的很慢的情况。</p></li></ol><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626202.png" alt="rate"></p><h3 id="Root-Mean-Square与RMSProp"><a href="#Root-Mean-Square与RMSProp" class="headerlink" title="Root Mean Square与RMSProp"></a>Root Mean Square与RMSProp</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626112.png" alt="02"></p><p>引入一个新的参数$\sigma_i^t$, 这样可以实现learning rate自动调整的目的，但这样存在一个问题，那就是最开始移动的g与最近移动的g对于$\sigma$的大小的影响是相同的，这样learning rate对于g变化的反应是比较缓慢的，那么做到让learning rate更快地对g变化做出反应呢？我们可以使用RMSProp</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626066.png" alt="sig"></p><h3 id="learning-Rate-Scheduling"><a href="#learning-Rate-Scheduling" class="headerlink" title="learning Rate Scheduling"></a>learning Rate Scheduling</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626133.png" alt="yz"></p><p>在进入grandient较小的区域后，在纵轴方向累计了很多很小的$\sigma$,当累计到一定程度后，可能就会出现如图所示的情况。为了解决这一问题，可以使用learning Rate Scheduling</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626124.png" alt="？？"></p><p>即让$\eta$也随移动而变化，如何变化呢？有两种方案：</p><ul><li>learning rate decay：即从大到小，</li><li>warm up：先从小增大到一定程度，再减小，原因：刚开始的$\sigma$是不准确的，因此先缓慢移动，等$\sigma$达到一定的准确程度，再继续快速移动.</li></ul><h3 id="自动更新学习速率-Momentum"><a href="#自动更新学习速率-Momentum" class="headerlink" title="自动更新学习速率+Momentum"></a>自动更新学习速率+Momentum</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101626524.png" alt="s+m"></p><p>在$\sigma$的更新过程中，是与方向无关的（取了平方），因此与momentum不会抵消。</p><h2 id="批次标准化（batch-normalization）"><a href="#批次标准化（batch-normalization）" class="headerlink" title="批次标准化（batch normalization）"></a>批次标准化（batch normalization）</h2><p>当一个模型的多个输入差异比较大时（比如$x_1$在0-1，$x_2$在100-200之间，那么$x_1$如果发生改变对最后Loss的影响一定是远大于$x_2$的，因此我们希望<strong>让不同维度的输入有一致的范围，让优化更简单</strong></p><h3 id="feature-Normalization（特征归一化）"><a href="#feature-Normalization（特征归一化）" class="headerlink" title="feature Normalization（特征归一化）"></a>feature Normalization（特征归一化）</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627635.png" alt="feature normalization"></p><p>我们将每个维度的输入都转化为同一范围的量的过程称为标准化，如上图所示即为标准化的过程，但是图中的标准化mean和$\sigma_i$的来源都是所有资料，但是我们知道，我们正常是要分成很多个batch，那么该怎么办呢？</p><h3 id="batch-Normalization"><a href="#batch-Normalization" class="headerlink" title="batch Normalization"></a>batch Normalization</h3><p>每个batch并不是同步进行的，为了完成feature Normalization的过程，我们可以将求所有资料的mean和$\sigma$变为这个batch的。</p><h3 id="多次标准化"><a href="#多次标准化" class="headerlink" title="多次标准化"></a>多次标准化</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627581.png" alt="deep-num"></p><p>在深度学习中，是有多层layer的，上一个layer的输出也是下一个layer的输入，第一层输入做了feature Normalization，但后面的输出却没有做，这显然是不合理的，因此我们可以对每层的输出都做一个feature Normalization。至于这个feature Normalization放在sigmoid这类激化函数前后都是可以的（不过sigmoid一般建议放在前面，因为sigmoid函数在0附近grandient较大)。</p><p>在某些情况下，我们希望最后的输出并不是以0为mean的，因此在输出精确到一定程度后可以对其进行变换：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627440.png" alt="afbt"></p><h3 id="testing时的batch-Normalization"><a href="#testing时的batch-Normalization" class="headerlink" title="testing时的batch Normalization"></a>testing时的batch Normalization</h3><p>在实际使用的测试过程中，可能一次输入并没有一个batch，这时batch Normalization可能会出现问题，pytorch给了解决方案，即在训练时每一个batch，都会将其mean和$\sigma$拿来做一个平均值，之后用来作为测试时的mean和标准差</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101627436.png" alt="meanmean"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 卷积神经网络(CNN)</title>
      <link href="blog/05%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/"/>
      <url>blog/05%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h2><p>输入：图片（默认大小是一致的）</p><p>输出：独热码（每个独热码代表其中一种分类）</p><h3 id="卷积神经网络的第一种表达"><a href="#卷积神经网络的第一种表达" class="headerlink" title="卷积神经网络的第一种表达"></a>卷积神经网络的第一种表达</h3><h4 id="如何把一张影响变成输入？"><a href="#如何把一张影响变成输入？" class="headerlink" title="如何把一张影响变成输入？"></a>如何把一张影响变成输入？</h4><p>每张图片实际上是一个三维的tensor，三个维度：长、宽、层数（例如：RGB三个channels），将其拉直成一个向量，即可实现影像输入（如下图所示）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118668.PNG" alt="将图片作为输入"></p><p>在拉直得到的向量中，每个元素的数值即代表了某一个位置某一种颜色的强度。</p><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>如果安装原来的Fully Connected Network对输入的向量进行处理，太过复杂，会增大overfitting的风险，那么该如此简化呢？</p><h5 id="每个Neuron只负责图片的一小部分"><a href="#每个Neuron只负责图片的一小部分" class="headerlink" title="每个Neuron只负责图片的一小部分"></a>每个Neuron只负责图片的一小部分</h5><p>每个Neuron的图片的部分称为一个receptive field，不同Neuron的receptive field可以重叠，多个Neuron可以负责一个receptive field（因为一些图片的特征可能不只有一个）。</p><p><strong>最经典的receptive field安排方式</strong></p><p>每个Neuron负责所有channels ，长和宽一般3x3，一个receptive field移动stride（自定义）即可得到另一个receptive field（stride自定义），移动时超出范围，可补0。</p><h5 id="共享参数"><a href="#共享参数" class="headerlink" title="共享参数"></a>共享参数</h5><p>一个特征可能同时出现一个图片的不同位置；因为我们可以让负责这一特征的Neuron共享参数</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118669.PNG" alt="共享参数"></p><p>每个receive field都有一组neuron在负责，不同receive field的对应neuron共享参数，我们将每一个neuron的参数称为一个fitler（卷积核）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118670.PNG" alt="如何共享参数"></p><p>在经过2.1和2.2后的网络层就是<strong>卷积层</strong>，使用卷积层的神经网络即为<strong>卷积神经网络</strong>。</p><h3 id="卷积神经网络的另一种表达"><a href="#卷积神经网络的另一种表达" class="headerlink" title="卷积神经网络的另一种表达"></a>卷积神经网络的另一种表达</h3><p><strong>feature map</strong></p><p>用n个filter对图片的特征进行抓取，每个filter负责一个特征。在一个filter的抓取全部完成后可以得到一个一层的tensor（如下图）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118671.PNG" alt="filter1"></p><p>而n个filter全部进行一遍后既可得到一个n层的tensor，即为一个feature map。而feature map又可以看出一个拥有n个channels的图片，作为下一层的输入，而下一层的filter也要是一个n个channels的tensor（如下图）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118672.PNG" alt="多层卷积"></p><p>如果使用3*3的filter是否可以抓取原图像中更大部分才能体现的特征？答案是可以的，因为使用了多层卷积之后得到的feature map中可以一个元素就能体现出原来很大部分的特征。</p><h3 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h3><p>将一个比较大图片做一个subsampling（如把偶数的行、奇数列去除），图片变为原来的1/4，但不会影响图片特征的提取</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118673.PNG" alt="pool"></p><p>如何做pooling？</p><p>将每个filter经过提取后得到的tensor中元素分成几个小组，从组中选出有代表性的元素留下来，其他元素去除（如下图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118674.PNG" alt="pooling"></p><p>max pooling：选择最大的元素作为代表。</p><p>pooling会对精确度造成损失，因此也<strong>可以不用</strong>。</p><h3 id="CNN图片识别流程"><a href="#CNN图片识别流程" class="headerlink" title="CNN图片识别流程"></a>CNN图片识别流程</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052118675.PNG" alt="THE WHOLE CNN"></p><p>经过卷积和池化（pooling，可以不用）后的输出经过flatten可以得到一个向量，再经过全连接层和softmax即可得到最后的输出</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 Classification</title>
      <link href="blog/04%20Classification%EF%BC%88%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>blog/04%20Classification%EF%BC%88%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><h3 id="如何做分类"><a href="#如何做分类" class="headerlink" title="如何做分类"></a>如何做分类</h3><ul><li><p>当作预测数值</p><p>每个分类之间是无关的，但预测的数值之间却存在关系的远近，例如将预测结果0当作分类A，预测结果1当作分类B，预测结果100当作分类C，显然预测数值1和2之间关系要比1和100更接近，但分类A,B,C之间是不存在这种关系的，因此这种做法并不合适。</p></li><li><p>把每个分类结果当作独热码</p></li></ul><h3 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116882.PNG" alt="softmax"></p><p>Classification需要对结果进行一次softmax，softmax步骤如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116883.PNG" alt="soft-max"></p><p>这样得到的结果，全都在0-1，且和为1</p><h3 id="Loss-of-Classification"><a href="#Loss-of-Classification" class="headerlink" title="Loss of Classification"></a>Loss of Classification</h3><p>在进行分类时对Loss的定义</p><ol><li><p>Mean Square Error(MSE)</p><script type="math/tex; mode=display">e = \sum_i(\widehat{y}_i-\dot{y_i})^2</script></li><li><p>Cross-entropy </p><script type="math/tex; mode=display">e = -\sum_i\widehat{y}_iln\dot{y_i}</script></li></ol><p><strong>分类时cross-entroy更适用。</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052116884.PNG" alt="cross"></p><p>如上图所示，MSE的结果在Loss比较大时grandient比较小，更难update到loss小的地方，而cross-entropy的结果更有利于优化（optimization）。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07 Transformer</title>
      <link href="blog/07%20Transformer/"/>
      <url>blog/07%20Transformer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><blockquote><p>这是一个sequence-to-sequence（seq2seq）的模型</p></blockquote><p>可以解决不知道输出长度的问题，例如</p><ul><li><p>语音辨识</p></li><li><p>multi-label classification</p></li><li><p>object detection</p></li><li><p>……</p></li></ul><h3 id="Transformer内部架构"><a href="#Transformer内部架构" class="headerlink" title="Transformer内部架构"></a>Transformer内部架构</h3><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117984.PNG" alt="transformer"></p><p>Transformer主要由encoder和decoder两部分组成，encoder可以实现输出一排长度与输入相同的向量，decoder可以实现输出一排由模型自己决定的长度的向量。</p><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><blockquote><p>给一排向量，输出同样长度的一排向量</p></blockquote><p>encoder包含了很多个block，</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117985.PNG" alt="encoder"></p><p>每个block包括的过程如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117986.PNG" alt="encoderblock"></p><p>即输入的一排向量（b），先经过一次self-attention得到a,之后与原输入向量（b）相加（residual network）得到a+b，再经过一次layer normalization得到c，得到的结果c作为下一层的输入，在下一层将经过一次全连接层得到d，d会与c相加（residual network）得到c+d，经过一次layer normalization后得到这个block的输出。</p><h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><h5 id="Autoregressive（AT，常见的一种decoder）"><a href="#Autoregressive（AT，常见的一种decoder）" class="headerlink" title="Autoregressive（AT，常见的一种decoder）"></a>Autoregressive（AT，常见的一种decoder）</h5><p>AT 这种decoder的输出是一个一个产生的，在最开始时，decoder会有一个开始符（begin）和encoder的输出一起作为输入，得到第一个输出的向量（得到输出向量的过程是一个概率分布，例如经过decoder后，得到每个字对应分数，“机”字得分占总得分的0.8，“你”占0.1，“end”（结束符，输出此向量后，结束输出）占0.1，那么“机”字就有0.8的概率作为输出），之后此向量代替开始符和encoder的输出一起作为下一次的输入，依次类推，直至输出结束符（end）。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117987.PNG" alt="at"></p><h5 id="decoder的内部结构"><a href="#decoder的内部结构" class="headerlink" title="decoder的内部结构"></a>decoder的内部结构</h5><blockquote><p>decoder的结构与encoder相似</p></blockquote><p><strong>masked Multi-Head Attention</strong></p><p>decoder的Multi-Head Attention需要masked，那么什么是masked呢？</p><p>就是在做注意力机制时，不考虑右边的向量，即将右边的masked，如图所示</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117988.PNG" alt="masked"></p><p>在产生$b^1$时只能考虑$a^1$而不能考虑$a^1$之后的。</p><p><strong>cross attention</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117989.PNG" alt=" "></p><p>在decoder经过masked Multi-Head Attention后和encoder的输出一起做了下一个模块的输入，这个模块即为cross attention，其具体过程如下图所示：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117990.PNG" alt="crossattention"></p><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><p>同时产生多个输出，decoder的输入一直都是begin和encoder的输出（即不会像AT那样将decoder的输出作为输入），实现平行化，速度更快，但是效果不好。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117991.PNG" alt="nat"></p><p>NAT如何解决在合适时候停止的问题？</p><ol><li>另外训练一个模型，输入为encoder的输出，输出为一个数字（代表decoder应该输出的长度）</li><li>给一个比较大数量的begin，这样就会输出一个很长的向量集合，再决定在哪里断开。</li></ol><h5 id="训练过程（train）"><a href="#训练过程（train）" class="headerlink" title="训练过程（train）"></a>训练过程（train）</h5><p><strong>teacher forcing</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117992.PNG" alt="traintransformer"></p><p>在decoder的训练过程中，会直接把正确的答案作为decoder的输入，这个过程称为teacher forcing，这个过程可能会导致mismatch。</p><h3 id="训练transformer的一些tips"><a href="#训练transformer的一些tips" class="headerlink" title="训练transformer的一些tips"></a>训练transformer的一些tips</h3><p><strong>chat-bot</strong></p><p>复制一些内容，例如聊天机器人、做摘要等。可以使用pointer network。</p><p><strong>guided attention</strong></p><p>要求在学习过程中的attention有一些属性是固定的。</p><p><strong>beam search</strong></p><p>可能每次都选最好的结果最后反而效果不好，可以在一些时候舍弃一些东西，加一些随机性。，例如下图中红色的路和绿色的路：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117993.PNG" alt="beem search"></p><p><strong>Scheduled Sampling</strong></p><p>如何解决train中使用了正确答案导致可能出现mismatch的问题？</p><p>可以给一些错误的答案。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06 self-attention</title>
      <link href="blog/06%20self-attention/"/>
      <url>blog/06%20self-attention/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h2><p>输入：一个向量的集合（例如：音频、语句、图、分子等）</p><p>输出： </p><ul><li><p>case1：输入输出长度一样（例如文字处理过程中的词性标注）</p></li><li><p>case2：只输出一个label</p></li><li><p>case3： 不知道需要输出多少个label</p></li></ul><h3 id="为什么要使用self-attention"><a href="#为什么要使用self-attention" class="headerlink" title="为什么要使用self attention"></a>为什么要使用self attention</h3><p>对于case1，即输入输出长度一样的情况，又可以称为Sequence Labeling</p><p>如何解决这种问题？如果按照之前的，只使用全连接层（即每个向量经过各种Neuron得到最终的输出）得到的结果有着巨大的缺陷，因为这样在每个向量计算过程实际只考虑了一个向量，但是实际上，每个向量的输出与输入集合中其他向量都是存在关系的（例如，“I saw a saw”，这个句子中两个“saw”有着不同的词性，但只用全连接层输出可能相同），这种关系是我们需要考虑的。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117803.PNG" alt="isawasaw"></p><p>如何才能考虑到这种关系的存在呢？在这里引入了self attention。self attention的输入和输出个数是相同的，每个输入向量都会对应一个输出向量（该输出向量是考虑了该向量与输入集合内其他向量之间关系的），之后将self attention得到的输出向量作为后续网络层的输入，就可以达到实现考虑输入集合内关系的效果。</p><h3 id="如何实现self-attention"><a href="#如何实现self-attention" class="headerlink" title="如何实现self attention"></a>如何实现self attention</h3><h4 id="计算两个向量相关性的方法"><a href="#计算两个向量相关性的方法" class="headerlink" title="计算两个向量相关性的方法"></a>计算两个向量相关性的方法</h4><p>dot product &amp; additive</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305101644150.png" alt="计算attention"></p><h4 id="计算self-attention输出的过程"><a href="#计算self-attention输出的过程" class="headerlink" title="计算self attention输出的过程"></a>计算self attention输出的过程</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117804.PNG" alt="计算selfattention输出"></p><p>如上图所示，解释了如果得到其中一个输出（$b^1$）的过程,而得到其他输出的过程与之类似。</p><p>而整个过程的矩阵表达如下：</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117805.PNG" alt="selfattention矩阵"></p><p>在这个过程中，只有三个变换所需矩阵是要经过学习得到的（$W^q,W^k,W^v$）。</p><h4 id="multi-head-self-attention"><a href="#multi-head-self-attention" class="headerlink" title="multi-head self-attention"></a>multi-head self-attention</h4><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117806.PNG" alt="mutiself"></p><p>在有些情况下，输入集合内向量的关系并不是只有一种类型，因此我们可以使用multi-head self-attention，这样可以考虑多种关系。实现过程是在原有self-attention的基础上增加$W^q,W^k,W^v$的数量。</p><h4 id="positional-encoding"><a href="#positional-encoding" class="headerlink" title="positional encoding"></a>positional encoding</h4><p>在某些情况下，输入集合内向量的位置也是很重要的（例如句子中第一个单词往往是主语），</p><p>因此在这种情况下，我们可以使用一组向量（$e^1,e^2,…，e^i)$存储位置，每个位置对应的向量是不同的，将其作为输入，这样在学习过程中就会考虑位置的因素。（如下图）</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117807.PNG" alt="position"></p><h3 id="self-attention的应用"><a href="#self-attention的应用" class="headerlink" title="self attention的应用"></a>self attention的应用</h3><h4 id="语言识别"><a href="#语言识别" class="headerlink" title="语言识别"></a>语言识别</h4><p><strong>truncated self-attention</strong></p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117808.PNG" alt=""></p><p>由于音频的数据量是很庞大的，如果全都拿来做self attention，运算量较大，因此我们可以每次只考虑附近几个向量之间的关系，即truncated self-attention，如上图所示。</p><h4 id="影像处理"><a href="#影像处理" class="headerlink" title="影像处理"></a>影像处理</h4><p><strong>self-attention VS CNN</strong></p><p>CNN是self attention的一个特例，之前说CNN中是把一个图片拼成一个向量作为输入，实际上，也可以将其作为一个向量的集合作为输入，使用self attention解决。</p><h4 id="图处理"><a href="#图处理" class="headerlink" title="图处理"></a>图处理</h4><p>在图中节点之间是否有连线实际上说明了节点之间的关系，所以我们可以只考虑之间有连线的节点之间的关系。</p><p><img src="https://zjyimage.oss-cn-beijing.aliyuncs.com/202305052117809.PNG" alt="GNN"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换链表中的节点</title>
      <link href="blog/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>blog/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>示例 1：</p><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">None</span> <span class="keyword">and</span> head.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            temp = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = temp</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            first = head</span><br><span class="line">            second = head.<span class="built_in">next</span></span><br><span class="line">            others = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line">            first.<span class="built_in">next</span> = swap(others)</span><br><span class="line">            <span class="keyword">return</span> second</span><br><span class="line">        <span class="keyword">return</span> swap(head)</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>这道题解一思路较为简单，只要注意需要用到中间变量temp，保证不会有节点丢失即可，可以画图来辅助解题；</li><li>解二使用了递归，根据题意我们可以知道这个过程始终是first与second所指链点交换位置，而下一轮first和second也能在上一轮过程中得到，因此可以使用递归的做法，要注意返回值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>blog/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 - 力扣（LeetCode）</a></p><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> target-i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> nums.index(i) != nums.index(target-i):</span><br><span class="line">                    <span class="keyword">return</span> [nums.index(i),nums.index(target-i)]</span><br><span class="line">                <span class="keyword">elif</span> nums.count(i)&gt;<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> [nums.index(i),nums.index(i)+nums[nums.index(i)+<span class="number">1</span>:].index(i)+<span class="number">1</span>]    </span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target-j <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-j],i]</span><br><span class="line">            hashtable[j] = i </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一采用了暴力求解，遍历列表时查询其对应的target-i是否在列表中，但直接使用index查询，时间复杂度较大，且需要考虑与自己匹配的问题；</li><li><p>解二使用了字典实现哈希表，字典的键为nums中的值，字典的值为位置，因此可以更方便地查询target-j是否存在，且保障了不会出现与自己匹配的情况（因为在查询时，哈希表中并没有当前元素自己）。</p></li><li><p>解二使用了enumerate（）函数，该函数的作用是返回一个可迭代对象，由原列表中元素对应位置与原列表中元素的值组成。默认位置是从0开始的，但是如果给enumerate（）函数起点位置参数，也可以实现从其他地方开始，例如enumerate（nums，1），则返回的起点是1。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="blog/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>blog/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</span><br></pre></td></tr></table></figure><p>示例 1:</p><blockquote><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p></blockquote><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">            middle = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt;target:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="keyword">elif</span> :</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">            middle = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt;target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>二分查找需要注意对区间的定义：target所在区间可能为[a,b）,也可能为[a,b],当使用左闭右开区间时，右端点是没有意义的，因此left &lt; right , right = middle,而在使用闭区间时，右端点有意义，因此left &lt;= right , right = middle -1 ，这也是解二和解三的区别；</li><li>python中index()方法，可以查找列表中对应元素的位置，除了代码中用法外，还可以给它第二、三个参数，例如nums.index(target,2，4) ，使其从列表中第2个元素开始找target对应索引到第4个元素处停止（序号从0开始)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除链表的倒数第N个节点</title>
      <link href="blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>blog/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><blockquote><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span> <span class="keyword">and</span> index &lt; n:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index != n:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>删除链表倒数第N个节点，最无脑粗暴的方法就是直接先遍历一遍，得到链表长度，之后确定要删除节点的位置，再进行删除，但这种方法时间复杂度较高，不是特别好；</li><li>第二种方法即为使用双指针法，因为要删除节点位置与尾端的距离是一定的，我们可以利用这个关系，在一开始就让两个指针指向节点之间距离与其相同，即先让p走n步，之后再一起走，当p走到尾端时，q指向即为要删除的节点（解中使用了虚拟头节点，因此p.next ，q.next才是笔记中的p，q），要注意一些特殊情况，例如n大于链表长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="blog/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 </a></p><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; length-<span class="number">1</span>:</span><br><span class="line">            temp = ListNode()</span><br><span class="line">            temp = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = temp</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        head = q</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        q = ListNode()</span><br><span class="line">        q = head</span><br><span class="line">        temp = ListNode()</span><br><span class="line">        temp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span>:</span><br><span class="line">            p = q</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = temp</span><br><span class="line">            temp = p</span><br><span class="line">        head = p</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">p,q</span>):</span></span><br><span class="line">            <span class="keyword">if</span> q == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            temp = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            <span class="keyword">return</span> reverse(q,temp)</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">None</span>,head)</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>翻转链表可以考虑使用双指针法，但是双指针之间亦有差别，例如：</p><ul><li>解一中两个指针分别放在原链表的首尾端，依次将首端的链点用头插法插在尾部指针指向链点的后面，这样，当原链表中链点全部加入尾端时，就成功实现了链表的反转，新链表首节点即为q.next（注意，其实原链表的尾端可以直接当作新链表的首端的，这一原来的尾端指针q就是head了，解一中也是这样写的）</li><li>解二中两个指针刚开始都在首段的，它们每往后移动一位都会将原来两个链点之间的指向反转（q指针的意义是为p指针指路，防止p指针在p.next = temp后无法找到原链表后续的链点）</li></ul></li><li><p>因为我采用了虚拟节点，因此需要格外注意原链表的第一个链点和原链表为None这两种情况;</p></li><li><p>解三的思路与解二是一样的，但是使用了递归：我们可以看出解二的过程实际上是p，temp两个指针指向链点之间指针的反转，可以用递归来处理，要注意递归时输入形参是什么（即要注意在下一次循环中p，temp对应什么），还要注意递归需要有停止的途径。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的平方</title>
      <link href="blog/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>blog/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><blockquote><p>给你一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>示例 1：</p><p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums_new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            nums_new.append(i*i)</span><br><span class="line">        nums_new.sort()</span><br><span class="line">        <span class="keyword">return</span> nums_new</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        nums_new = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            temp = i*i</span><br><span class="line">            <span class="keyword">if</span> nums_new == []:</span><br><span class="line">                nums_new.append(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> nums_new:</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= temp:</span><br><span class="line">                        nums_new.insert(nums_new.index(i),temp)</span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                    nums_new.append(temp)</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> nums_new</span><br></pre></td></tr></table></figure><p>解三：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> nums[i]*nums[i] &lt; nums[j]*nums[j]:</span><br><span class="line">                result.insert(<span class="number">0</span>,nums[j]*nums[j])</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.insert(<span class="number">0</span>,nums[i]*nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解法一，先得到列表内所有元素平方之后再对其进行排序，解法二，在得到列表内每个元素的平方之后，利用直接插入排序的思路对其进行排序，最后得到已经排序的平方列表；但这两种方法时间复杂度都较高。</li><li>根据题意可知，原列表内元素平方后得到的新列表中，并不是没有顺序，只是最小值在中间（原列表有负数时），最大值在两端而已，因此可以用两个指针分别指向首段和尾端，根据$(nums[i])^{2}$和$(nums[j])^{2}$的大小判断将哪一端先放入结果中，放入结果的端点的指针需要移动。此外需要注意循环的条件，首端指针i，末端指针j，其判断条件应为i &lt;= j，否则会出现在最后有一个指针指向元素的平方未放入结果列表的情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="blog/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">142. 环形链表 II - 力扣（LeetCode）</a></p><blockquote><p> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        lis = []</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">in</span> lis:</span><br><span class="line">                <span class="keyword">return</span> p.<span class="built_in">next</span></span><br><span class="line">            lis.append(p.<span class="built_in">next</span>)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        p,q = head,head</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span> <span class="keyword">and</span> p.<span class="built_in">next</span>!=<span class="literal">None</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                p = head</span><br><span class="line">                <span class="keyword">while</span> p != q:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>解一将所有遍历过的链点都存储在一个列表中，判断新遍历的列表是否在列表中，若已在列表中，就说明在这里产生了环；</li><li>解二使用了双指针法，当快指针与慢指针相遇时，设慢指针走了k，与环起点距离为m，则快指针走了2k，且从相遇点到环起点的距离$L_1$和从head到环起点的距离$L_2$均为k-m，这时我们可以设置快慢指针中一个指针指向head，两指针以同样速率移动，当两指针相遇，则相遇点恰好为环的起点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>blog/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">len</span> = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 </strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 50</li><li>0 &lt;= val &lt;= 100</li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>解一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums_new = nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums_new:</span><br><span class="line">            <span class="keyword">if</span> i == val:</span><br><span class="line">                nums.remove(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>解二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>解三(示例代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def removeElement(self, nums, val):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while i &lt; len(nums):</span><br><span class="line">            if nums[i] &#x3D;&#x3D; val:</span><br><span class="line">                nums.pop(i)</span><br><span class="line">                i &#x3D; i - 1</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        return len(nums)</span><br></pre></td></tr></table></figure><p>解四（双指针法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>在python中，使用了remove（），该方法会移除列表中的某个值的第一个匹配项。但是需要注意，如果需要删除的值在列表中有相邻的，只用一次for循环+remove（）无法将其全部删除，因为remove（）方法会改变列表中原有的索引。可以采取的方案：为该列表创建一个副本，for循环遍历副本，但删除原列表中元素（即解一做法，但这种情况与题意“仅使用O（1）额外空间不符”），也可以使用while循环来删除对应元素；</li><li>示例代码给出了另一种思路，即使用索引，用pop（）方法进行删除；</li><li>也可使用双指针法，两个指针一快一慢，遍历整个列表，当快指针指向的元素为需要删除的时，慢指针不动快指针后移，当快指针指向元素不是需要删除的时， nums[slow] = nums[fast]，且快慢指针均后移。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="blog/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>blog/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p><p>示例 1：</p><p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">#class ListNode(object):</span></span><br><span class="line">    <span class="comment">#def __init__(self, val=0, next=None):</span></span><br><span class="line">        <span class="comment">#self.val = val</span></span><br><span class="line">        <span class="comment">#self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val == val:</span><br><span class="line">                head = p.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">if</span> p.val == val:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            head = p</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>解二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sta = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        p = sta</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>python中不可变数据类型有：整型、浮点型、元组（改变变量值后，变量指向内存位置改变即为不可变类型）；</li><li>python中也是有指针的，python采用基于值的内存管理模式，每个变量都可以理解为指针（这也是为什么要用a = b[:]来创建一个不会影响原列表的列表副本），当指向不可变数据类型的变量改变值，会发生指向内存位置的改变；</li><li>解二中将后续移动的指针定义在head前面，即p.next = head，这样之后就不需要将链表首端和尾端为需要删除链点当作特殊情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计链表</title>
      <link href="blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>blog/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p><blockquote><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p><p>实现 MyLinkedList 类：</p><p>MyLinkedList() 初始化 MyLinkedList 对象。<br>int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。<br>void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。<br>void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。<br>void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。<br>void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.length:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        node = ListNode(val, self.head)</span><br><span class="line">        self.head = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = ListNode(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.length:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">        <span class="keyword">elif</span> index == self.length:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            node = ListNode(val, current.<span class="built_in">next</span>)</span><br><span class="line">            current.<span class="built_in">next</span> = node</span><br><span class="line">            self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.length:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.length -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span></span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.size = <span class="number">0</span> <span class="comment"># 设置一个链表长度的属性，便于后续操作，注意每次增和删的时候都要更新</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span>(index):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(val)</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        new_node = Node(val)</span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span>(cur.<span class="built_in">next</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            self.addAtHead(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index == self.size:</span><br><span class="line">            self.addAtTail(val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        node = Node(val)</span><br><span class="line">        pre = self.head</span><br><span class="line">        <span class="keyword">while</span>(index):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type index: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre = self.head</span><br><span class="line">        <span class="keyword">while</span>(index):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>这道题目思路不难，但是需要注意的细节很多，例如在首端增添元素，原链表为空等等，需要全方面地考虑;</li><li>要善于利用python的一些语法，例如链表中指针的移动可以借助for循环实现（如题1）;</li><li>除了单链表外，还可以考虑双链表（相对于单链表，多了prev属性）；</li><li>对链表的操作可以考虑使用虚拟结点（如解2）会比解一方便些（例如链表为空的情况不需要特别处理）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相交</title>
      <link href="blog/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
      <url>blog/%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = headA)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = headB)</span><br><span class="line">        lista = []</span><br><span class="line">        listb = []</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            lista.append(p.<span class="built_in">next</span>.val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            listb.append(q.<span class="built_in">next</span>.val)</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        index_0 = <span class="number">0</span></span><br><span class="line">        index_1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lista)):</span><br><span class="line">            <span class="keyword">if</span> lista[i] <span class="keyword">in</span> listb:</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> lista[i] <span class="keyword">in</span> listb[j+<span class="number">1</span>:]:</span><br><span class="line">                    j = listb[j+<span class="number">1</span>:].index(lista[i])</span><br><span class="line">                    index_0 = i</span><br><span class="line">                    index_1 = j</span><br><span class="line">                    fp = headA</span><br><span class="line">                    fq = headB</span><br><span class="line">                    <span class="keyword">while</span> index_0:</span><br><span class="line">                        fp = fp.<span class="built_in">next</span></span><br><span class="line">                        index_0 -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> index_1:</span><br><span class="line">                        fq = fq.<span class="built_in">next</span></span><br><span class="line">                        index_1 -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> fp == fq:</span><br><span class="line">                        head1 = fp</span><br><span class="line">                        <span class="keyword">return</span> head1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = headA)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = headB)</span><br><span class="line">        num1 = num2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            num1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">            num2 += <span class="number">1</span></span><br><span class="line">        k = num1 - num2</span><br><span class="line">        p = ListNode(<span class="built_in">next</span> = headA)</span><br><span class="line">        q = ListNode(<span class="built_in">next</span> = headB)</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> k:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> k:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span> == q.<span class="built_in">next</span>:</span><br><span class="line">                head1 = p.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> head1</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li><p>解一暴力解法，逐个遍历，将两个链表val存在列表中，找到两个链表重叠元素的位置（这两个节点不一定相交，因为next不一定相同），之后判断对应链点是否相同</p><p>值得注意的是，这种解法需要对一些特殊情况进行处理，比如在相交节点前，某一链表有一个val相同的节点，而另一个链表相交节点前没有val相同的节点，例如：</p><p>链表1：[4,1,8,4,5]、链表2：[8,0,1,8,4,5]，相交节点为第一个链表的2号和第二个链表的3号；</p><p>但由于链表2的0号也是8，在与链表1的2号一起判断后未通过，会导致链表1的2号被错误地遍历过去，针对此情况，可以在加一个循环 while lista[i] in listb[j+1:]（此情况leetcode未检查出来，加循环后又会超出时间限制）；</p></li><li><p>解二使用了双指针法的思想，当两个链表交叉，那么相交节点后的链表是一样的，因此可以让较长链表上的指针移动到与较短链表首端对应的位置，之后依次后移，判断对应链点是否相同，可以有效避免解一中的特殊情况，且时间复杂度较低。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度最小的子数组</title>
      <link href="blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>blog/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一（会超出时间限制）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result_final = []</span><br><span class="line">        tim = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[t:]:</span><br><span class="line">                <span class="built_in">sum</span> += i</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                    result_final.append(flag)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> result_final == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(result_final)</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            num = num + nums[end]</span><br><span class="line">            <span class="keyword">while</span> num &gt;= target:</span><br><span class="line">                result = <span class="built_in">min</span>(result,end - first+<span class="number">1</span>)</span><br><span class="line">                num = num - nums[first]</span><br><span class="line">                first += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> result == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>暴力求解（即解一），时间复杂度较高，会超出时间限制；</li><li>采用滑动窗口法（双指针法），两个指针一个指向所求区间尾端（end），另一个指向所求区间首段（first），根据题意要求的是最小的能使其和大于等于target的区间，因此当区间内和小于target时尾端应该右移，扩大区间，当区间内和大于等于target时，首端应右移，减少区间内元素个数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>螺旋矩阵</title>
      <link href="blog/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>blog/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">52-螺旋矩阵</a></p><blockquote><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p>示例 1：</p><p>输入：n = 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]</p></blockquote><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>解一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        resmatrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        num = <span class="number">4</span> * (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            resmatrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> resmatrix</span><br><span class="line">        <span class="keyword">while</span> count &lt;= n * n:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= num / <span class="number">4</span> - <span class="number">1</span>:</span><br><span class="line">                    resmatrix[loop][loop + i] = count</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; num / <span class="number">4</span> - <span class="number">1</span> <span class="keyword">and</span> i &lt;= <span class="number">2</span> * num / <span class="number">4</span> - <span class="number">1</span>:</span><br><span class="line">                    resmatrix[<span class="built_in">int</span>(loop + (i - num/<span class="number">4</span>))][<span class="built_in">int</span>(loop + num/<span class="number">4</span>)] = count</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">2</span> * num / <span class="number">4</span> - <span class="number">1</span> <span class="keyword">and</span> i &lt;= <span class="number">3</span> * num / <span class="number">4</span> - <span class="number">1</span>:</span><br><span class="line">                    resmatrix[<span class="built_in">int</span>(loop + num / <span class="number">4</span>)][<span class="built_in">int</span>(loop+num/<span class="number">4</span>-(i-<span class="number">2</span>*num/<span class="number">4</span>))] = count</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    resmatrix[<span class="built_in">int</span>(loop + num / <span class="number">4</span> - (i - <span class="number">3</span> * num / <span class="number">4</span>))][loop] = count</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            num -= <span class="number">8</span></span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                resmatrix[loop][loop] = n*n</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> resmatrix</span><br></pre></td></tr></table></figure><p>解二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        startx, starty = <span class="number">0</span>, <span class="number">0</span>              </span><br><span class="line">        loop, mid = n // <span class="number">2</span>, n // <span class="number">2</span>          </span><br><span class="line">        count = <span class="number">1</span>                          </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, loop + <span class="number">1</span>) :  </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(starty, n - offset) : </span><br><span class="line">                nums[startx][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startx, n - offset) :  </span><br><span class="line">                nums[i][n - offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, starty, -<span class="number">1</span>) : </span><br><span class="line">                nums[n - offset][i] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, startx, -<span class="number">1</span>) : </span><br><span class="line">                nums[i][starty] = count</span><br><span class="line">                count += <span class="number">1</span>                </span><br><span class="line">            startx += <span class="number">1</span>   </span><br><span class="line">            starty += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span> :</span><br><span class="line">            nums[mid][mid] = count </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol><li>对于此种问题，可以设法将其分解为一个个相似的过程（例如螺旋矩阵中的每一圈），抓住这些过程有哪些要素是相似的（在螺旋矩阵每圈中，四个角的坐标的计算），哪些要素是不变的（每圈中元素之间的关系都是顺时针依次+1），再从不变的因素出发，将相似的部分与变量联系起来，最终达到分析整个过程的目的；</li><li>需要特别注意一些特殊情况，例如解一中螺旋矩阵仅有一个元素时和解二中螺旋矩阵的中心（若n为奇数）；</li><li>解一解二的思路是相同的，但在一些细节的处理上存在差异例如对每一圈中坐标的计算，解一中每圈起点点初始设置为（loop，loop），而解二中起点坐标则是通过startx，starty不断加1得到。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
